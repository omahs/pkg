// Code generated by capnpc-go. DO NOT EDIT.

package cluster

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	stream "capnproto.org/go/capnp/v3/std/capnp/stream"
	context "context"
	anchor "github.com/wetware/pkg/api/anchor"
	process "github.com/wetware/pkg/api/process"
	pubsub "github.com/wetware/pkg/api/pubsub"
	registry "github.com/wetware/pkg/api/registry"
	strconv "strconv"
)

type Signer capnp.Client

// Signer_TypeID is the unique identifier for the type Signer.
const Signer_TypeID = 0xf1f2e144cec1f2bc

func (c Signer) Sign(ctx context.Context, params func(Signer_sign_Params) error) (Signer_sign_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf1f2e144cec1f2bc,
			MethodID:      0,
			InterfaceName: "cluster.capnp:Signer",
			MethodName:    "sign",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Signer_sign_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Signer_sign_Results_Future{Future: ans.Future()}, release

}

func (c Signer) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Signer) String() string {
	return "Signer(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Signer) AddRef() Signer {
	return Signer(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Signer) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Signer) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Signer) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Signer) DecodeFromPtr(p capnp.Ptr) Signer {
	return Signer(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Signer) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Signer) IsSame(other Signer) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Signer) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Signer) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Signer_Server is a Signer with a local implementation.
type Signer_Server interface {
	Sign(context.Context, Signer_sign) error
}

// Signer_NewServer creates a new Server from an implementation of Signer_Server.
func Signer_NewServer(s Signer_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Signer_Methods(nil, s), s, c)
}

// Signer_ServerToClient creates a new Client from an implementation of Signer_Server.
// The caller is responsible for calling Release on the returned Client.
func Signer_ServerToClient(s Signer_Server) Signer {
	return Signer(capnp.NewClient(Signer_NewServer(s)))
}

// Signer_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Signer_Methods(methods []server.Method, s Signer_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf1f2e144cec1f2bc,
			MethodID:      0,
			InterfaceName: "cluster.capnp:Signer",
			MethodName:    "sign",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Sign(ctx, Signer_sign{call})
		},
	})

	return methods
}

// Signer_sign holds the state for a server call to Signer.sign.
// See server.Call for documentation.
type Signer_sign struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Signer_sign) Args() Signer_sign_Params {
	return Signer_sign_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Signer_sign) AllocResults() (Signer_sign_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Signer_sign_Results(r), err
}

// Signer_List is a list of Signer.
type Signer_List = capnp.CapList[Signer]

// NewSigner creates a new list of Signer.
func NewSigner_List(s *capnp.Segment, sz int32) (Signer_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Signer](l), err
}

type Signer_sign_Params capnp.Struct

// Signer_sign_Params_TypeID is the unique identifier for the type Signer_sign_Params.
const Signer_sign_Params_TypeID = 0xb2250c16d3064727

func NewSigner_sign_Params(s *capnp.Segment) (Signer_sign_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Signer_sign_Params(st), err
}

func NewRootSigner_sign_Params(s *capnp.Segment) (Signer_sign_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Signer_sign_Params(st), err
}

func ReadRootSigner_sign_Params(msg *capnp.Message) (Signer_sign_Params, error) {
	root, err := msg.Root()
	return Signer_sign_Params(root.Struct()), err
}

func (s Signer_sign_Params) String() string {
	str, _ := text.Marshal(0xb2250c16d3064727, capnp.Struct(s))
	return str
}

func (s Signer_sign_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Signer_sign_Params) DecodeFromPtr(p capnp.Ptr) Signer_sign_Params {
	return Signer_sign_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Signer_sign_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Signer_sign_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Signer_sign_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Signer_sign_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Signer_sign_Params) Nonce() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Signer_sign_Params) HasNonce() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Signer_sign_Params) SetNonce(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

// Signer_sign_Params_List is a list of Signer_sign_Params.
type Signer_sign_Params_List = capnp.StructList[Signer_sign_Params]

// NewSigner_sign_Params creates a new list of Signer_sign_Params.
func NewSigner_sign_Params_List(s *capnp.Segment, sz int32) (Signer_sign_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Signer_sign_Params](l), err
}

// Signer_sign_Params_Future is a wrapper for a Signer_sign_Params promised by a client call.
type Signer_sign_Params_Future struct{ *capnp.Future }

func (f Signer_sign_Params_Future) Struct() (Signer_sign_Params, error) {
	p, err := f.Future.Ptr()
	return Signer_sign_Params(p.Struct()), err
}

type Signer_sign_Results capnp.Struct

// Signer_sign_Results_TypeID is the unique identifier for the type Signer_sign_Results.
const Signer_sign_Results_TypeID = 0xf00b0072c6dcfae7

func NewSigner_sign_Results(s *capnp.Segment) (Signer_sign_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Signer_sign_Results(st), err
}

func NewRootSigner_sign_Results(s *capnp.Segment) (Signer_sign_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Signer_sign_Results(st), err
}

func ReadRootSigner_sign_Results(msg *capnp.Message) (Signer_sign_Results, error) {
	root, err := msg.Root()
	return Signer_sign_Results(root.Struct()), err
}

func (s Signer_sign_Results) String() string {
	str, _ := text.Marshal(0xf00b0072c6dcfae7, capnp.Struct(s))
	return str
}

func (s Signer_sign_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Signer_sign_Results) DecodeFromPtr(p capnp.Ptr) Signer_sign_Results {
	return Signer_sign_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Signer_sign_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Signer_sign_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Signer_sign_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Signer_sign_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Signer_sign_Results) Envelope() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Signer_sign_Results) HasEnvelope() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Signer_sign_Results) SetEnvelope(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

// Signer_sign_Results_List is a list of Signer_sign_Results.
type Signer_sign_Results_List = capnp.StructList[Signer_sign_Results]

// NewSigner_sign_Results creates a new list of Signer_sign_Results.
func NewSigner_sign_Results_List(s *capnp.Segment, sz int32) (Signer_sign_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Signer_sign_Results](l), err
}

// Signer_sign_Results_Future is a wrapper for a Signer_sign_Results promised by a client call.
type Signer_sign_Results_Future struct{ *capnp.Future }

func (f Signer_sign_Results_Future) Struct() (Signer_sign_Results, error) {
	p, err := f.Future.Ptr()
	return Signer_sign_Results(p.Struct()), err
}

type Host capnp.Client

// Host_TypeID is the unique identifier for the type Host.
const Host_TypeID = 0x957cbefc645fd307

func (c Host) Login(ctx context.Context, params func(Host_login_Params) error) (Host_login_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x957cbefc645fd307,
			MethodID:      0,
			InterfaceName: "cluster.capnp:Host",
			MethodName:    "login",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Host_login_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Host_login_Results_Future{Future: ans.Future()}, release

}

func (c Host) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Host) String() string {
	return "Host(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Host) AddRef() Host {
	return Host(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Host) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Host) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Host) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Host) DecodeFromPtr(p capnp.Ptr) Host {
	return Host(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Host) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Host) IsSame(other Host) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Host) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Host) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Host_Server is a Host with a local implementation.
type Host_Server interface {
	Login(context.Context, Host_login) error
}

// Host_NewServer creates a new Server from an implementation of Host_Server.
func Host_NewServer(s Host_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Host_Methods(nil, s), s, c)
}

// Host_ServerToClient creates a new Client from an implementation of Host_Server.
// The caller is responsible for calling Release on the returned Client.
func Host_ServerToClient(s Host_Server) Host {
	return Host(capnp.NewClient(Host_NewServer(s)))
}

// Host_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Host_Methods(methods []server.Method, s Host_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x957cbefc645fd307,
			MethodID:      0,
			InterfaceName: "cluster.capnp:Host",
			MethodName:    "login",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Login(ctx, Host_login{call})
		},
	})

	return methods
}

// Host_login holds the state for a server call to Host.login.
// See server.Call for documentation.
type Host_login struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Host_login) Args() Host_login_Params {
	return Host_login_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Host_login) AllocResults() (Host_login_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return Host_login_Results(r), err
}

// Host_List is a list of Host.
type Host_List = capnp.CapList[Host]

// NewHost creates a new list of Host.
func NewHost_List(s *capnp.Segment, sz int32) (Host_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Host](l), err
}

type Host_login_Params capnp.Struct

// Host_login_Params_TypeID is the unique identifier for the type Host_login_Params.
const Host_login_Params_TypeID = 0xa404c24b5375b9e4

func NewHost_login_Params(s *capnp.Segment) (Host_login_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Host_login_Params(st), err
}

func NewRootHost_login_Params(s *capnp.Segment) (Host_login_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Host_login_Params(st), err
}

func ReadRootHost_login_Params(msg *capnp.Message) (Host_login_Params, error) {
	root, err := msg.Root()
	return Host_login_Params(root.Struct()), err
}

func (s Host_login_Params) String() string {
	str, _ := text.Marshal(0xa404c24b5375b9e4, capnp.Struct(s))
	return str
}

func (s Host_login_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Host_login_Params) DecodeFromPtr(p capnp.Ptr) Host_login_Params {
	return Host_login_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Host_login_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Host_login_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Host_login_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Host_login_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Host_login_Params) Account() Signer {
	p, _ := capnp.Struct(s).Ptr(0)
	return Signer(p.Interface().Client())
}

func (s Host_login_Params) HasAccount() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Host_login_Params) SetAccount(v Signer) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Host_login_Params_List is a list of Host_login_Params.
type Host_login_Params_List = capnp.StructList[Host_login_Params]

// NewHost_login_Params creates a new list of Host_login_Params.
func NewHost_login_Params_List(s *capnp.Segment, sz int32) (Host_login_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Host_login_Params](l), err
}

// Host_login_Params_Future is a wrapper for a Host_login_Params promised by a client call.
type Host_login_Params_Future struct{ *capnp.Future }

func (f Host_login_Params_Future) Struct() (Host_login_Params, error) {
	p, err := f.Future.Ptr()
	return Host_login_Params(p.Struct()), err
}
func (p Host_login_Params_Future) Account() Signer {
	return Signer(p.Future.Field(0, nil).Client())
}

type Host_login_Results capnp.Struct

// Host_login_Results_TypeID is the unique identifier for the type Host_login_Results.
const Host_login_Results_TypeID = 0x8f58928e854cd4f5

func NewHost_login_Results(s *capnp.Segment) (Host_login_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return Host_login_Results(st), err
}

func NewRootHost_login_Results(s *capnp.Segment) (Host_login_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return Host_login_Results(st), err
}

func ReadRootHost_login_Results(msg *capnp.Message) (Host_login_Results, error) {
	root, err := msg.Root()
	return Host_login_Results(root.Struct()), err
}

func (s Host_login_Results) String() string {
	str, _ := text.Marshal(0x8f58928e854cd4f5, capnp.Struct(s))
	return str
}

func (s Host_login_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Host_login_Results) DecodeFromPtr(p capnp.Ptr) Host_login_Results {
	return Host_login_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Host_login_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Host_login_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Host_login_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Host_login_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Host_login_Results) View() View {
	p, _ := capnp.Struct(s).Ptr(0)
	return View(p.Interface().Client())
}

func (s Host_login_Results) HasView() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Host_login_Results) SetView(v View) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

func (s Host_login_Results) PubSub() pubsub.Router {
	p, _ := capnp.Struct(s).Ptr(1)
	return pubsub.Router(p.Interface().Client())
}

func (s Host_login_Results) HasPubSub() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Host_login_Results) SetPubSub(v pubsub.Router) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(1, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(1, in.ToPtr())
}

func (s Host_login_Results) Root() anchor.Anchor {
	p, _ := capnp.Struct(s).Ptr(2)
	return anchor.Anchor(p.Interface().Client())
}

func (s Host_login_Results) HasRoot() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Host_login_Results) SetRoot(v anchor.Anchor) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(2, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(2, in.ToPtr())
}

func (s Host_login_Results) Registry() registry.Registry {
	p, _ := capnp.Struct(s).Ptr(3)
	return registry.Registry(p.Interface().Client())
}

func (s Host_login_Results) HasRegistry() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Host_login_Results) SetRegistry(v registry.Registry) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(3, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(3, in.ToPtr())
}

func (s Host_login_Results) Executor() process.Executor {
	p, _ := capnp.Struct(s).Ptr(4)
	return process.Executor(p.Interface().Client())
}

func (s Host_login_Results) HasExecutor() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Host_login_Results) SetExecutor(v process.Executor) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(4, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(4, in.ToPtr())
}

// Host_login_Results_List is a list of Host_login_Results.
type Host_login_Results_List = capnp.StructList[Host_login_Results]

// NewHost_login_Results creates a new list of Host_login_Results.
func NewHost_login_Results_List(s *capnp.Segment, sz int32) (Host_login_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5}, sz)
	return capnp.StructList[Host_login_Results](l), err
}

// Host_login_Results_Future is a wrapper for a Host_login_Results promised by a client call.
type Host_login_Results_Future struct{ *capnp.Future }

func (f Host_login_Results_Future) Struct() (Host_login_Results, error) {
	p, err := f.Future.Ptr()
	return Host_login_Results(p.Struct()), err
}
func (p Host_login_Results_Future) View() View {
	return View(p.Future.Field(0, nil).Client())
}

func (p Host_login_Results_Future) PubSub() pubsub.Router {
	return pubsub.Router(p.Future.Field(1, nil).Client())
}

func (p Host_login_Results_Future) Root() anchor.Anchor {
	return anchor.Anchor(p.Future.Field(2, nil).Client())
}

func (p Host_login_Results_Future) Registry() registry.Registry {
	return registry.Registry(p.Future.Field(3, nil).Client())
}

func (p Host_login_Results_Future) Executor() process.Executor {
	return process.Executor(p.Future.Field(4, nil).Client())
}

type Heartbeat capnp.Struct

// Heartbeat_TypeID is the unique identifier for the type Heartbeat.
const Heartbeat_TypeID = 0xa97471079836f720

func NewHeartbeat(s *capnp.Segment) (Heartbeat, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Heartbeat(st), err
}

func NewRootHeartbeat(s *capnp.Segment) (Heartbeat, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Heartbeat(st), err
}

func ReadRootHeartbeat(msg *capnp.Message) (Heartbeat, error) {
	root, err := msg.Root()
	return Heartbeat(root.Struct()), err
}

func (s Heartbeat) String() string {
	str, _ := text.Marshal(0xa97471079836f720, capnp.Struct(s))
	return str
}

func (s Heartbeat) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Heartbeat) DecodeFromPtr(p capnp.Ptr) Heartbeat {
	return Heartbeat(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Heartbeat) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Heartbeat) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Heartbeat) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Heartbeat) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Heartbeat) Ttl() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s Heartbeat) SetTtl(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

func (s Heartbeat) Server() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s Heartbeat) SetServer(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s Heartbeat) Host() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Heartbeat) HasHost() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Heartbeat) HostBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Heartbeat) SetHost(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Heartbeat) Meta() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s Heartbeat) HasMeta() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Heartbeat) SetMeta(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewMeta sets the meta field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Heartbeat) NewMeta(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// Heartbeat_List is a list of Heartbeat.
type Heartbeat_List = capnp.StructList[Heartbeat]

// NewHeartbeat creates a new list of Heartbeat.
func NewHeartbeat_List(s *capnp.Segment, sz int32) (Heartbeat_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[Heartbeat](l), err
}

// Heartbeat_Future is a wrapper for a Heartbeat promised by a client call.
type Heartbeat_Future struct{ *capnp.Future }

func (f Heartbeat_Future) Struct() (Heartbeat, error) {
	p, err := f.Future.Ptr()
	return Heartbeat(p.Struct()), err
}

type View capnp.Client

// View_TypeID is the unique identifier for the type View.
const View_TypeID = 0x8a1df0335afc249a

func (c View) Lookup(ctx context.Context, params func(View_lookup_Params) error) (View_lookup_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8a1df0335afc249a,
			MethodID:      0,
			InterfaceName: "cluster.capnp:View",
			MethodName:    "lookup",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 2}
		s.PlaceArgs = func(s capnp.Struct) error { return params(View_lookup_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return View_lookup_Results_Future{Future: ans.Future()}, release

}

func (c View) Iter(ctx context.Context, params func(View_iter_Params) error) (View_iter_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8a1df0335afc249a,
			MethodID:      1,
			InterfaceName: "cluster.capnp:View",
			MethodName:    "iter",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 3}
		s.PlaceArgs = func(s capnp.Struct) error { return params(View_iter_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return View_iter_Results_Future{Future: ans.Future()}, release

}

func (c View) Reverse(ctx context.Context, params func(View_reverse_Params) error) (View_reverse_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8a1df0335afc249a,
			MethodID:      2,
			InterfaceName: "cluster.capnp:View",
			MethodName:    "reverse",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(View_reverse_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return View_reverse_Results_Future{Future: ans.Future()}, release

}

func (c View) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c View) String() string {
	return "View(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c View) AddRef() View {
	return View(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c View) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c View) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c View) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (View) DecodeFromPtr(p capnp.Ptr) View {
	return View(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c View) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c View) IsSame(other View) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c View) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c View) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A View_Server is a View with a local implementation.
type View_Server interface {
	Lookup(context.Context, View_lookup) error

	Iter(context.Context, View_iter) error

	Reverse(context.Context, View_reverse) error
}

// View_NewServer creates a new Server from an implementation of View_Server.
func View_NewServer(s View_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(View_Methods(nil, s), s, c)
}

// View_ServerToClient creates a new Client from an implementation of View_Server.
// The caller is responsible for calling Release on the returned Client.
func View_ServerToClient(s View_Server) View {
	return View(capnp.NewClient(View_NewServer(s)))
}

// View_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func View_Methods(methods []server.Method, s View_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 3)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8a1df0335afc249a,
			MethodID:      0,
			InterfaceName: "cluster.capnp:View",
			MethodName:    "lookup",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Lookup(ctx, View_lookup{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8a1df0335afc249a,
			MethodID:      1,
			InterfaceName: "cluster.capnp:View",
			MethodName:    "iter",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Iter(ctx, View_iter{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8a1df0335afc249a,
			MethodID:      2,
			InterfaceName: "cluster.capnp:View",
			MethodName:    "reverse",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Reverse(ctx, View_reverse{call})
		},
	})

	return methods
}

// View_lookup holds the state for a server call to View.lookup.
// See server.Call for documentation.
type View_lookup struct {
	*server.Call
}

// Args returns the call's arguments.
func (c View_lookup) Args() View_lookup_Params {
	return View_lookup_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c View_lookup) AllocResults() (View_lookup_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_lookup_Results(r), err
}

// View_iter holds the state for a server call to View.iter.
// See server.Call for documentation.
type View_iter struct {
	*server.Call
}

// Args returns the call's arguments.
func (c View_iter) Args() View_iter_Params {
	return View_iter_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c View_iter) AllocResults() (View_iter_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return View_iter_Results(r), err
}

// View_reverse holds the state for a server call to View.reverse.
// See server.Call for documentation.
type View_reverse struct {
	*server.Call
}

// Args returns the call's arguments.
func (c View_reverse) Args() View_reverse_Params {
	return View_reverse_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c View_reverse) AllocResults() (View_reverse_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_reverse_Results(r), err
}

// View_List is a list of View.
type View_List = capnp.CapList[View]

// NewView creates a new list of View.
func NewView_List(s *capnp.Segment, sz int32) (View_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[View](l), err
}

type View_Handler capnp.Client

// View_Handler_TypeID is the unique identifier for the type View_Handler.
const View_Handler_TypeID = 0xee93a663b2a23c03

func (c View_Handler) Recv(ctx context.Context, params func(View_Handler_recv_Params) error) error {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xee93a663b2a23c03,
			MethodID:      0,
			InterfaceName: "cluster.capnp:View.Handler",
			MethodName:    "recv",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(View_Handler_recv_Params(s)) }
	}

	return capnp.Client(c).SendStreamCall(ctx, s)

}

func (c View_Handler) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c View_Handler) String() string {
	return "View_Handler(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c View_Handler) AddRef() View_Handler {
	return View_Handler(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c View_Handler) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c View_Handler) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c View_Handler) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (View_Handler) DecodeFromPtr(p capnp.Ptr) View_Handler {
	return View_Handler(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c View_Handler) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c View_Handler) IsSame(other View_Handler) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c View_Handler) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c View_Handler) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A View_Handler_Server is a View_Handler with a local implementation.
type View_Handler_Server interface {
	Recv(context.Context, View_Handler_recv) error
}

// View_Handler_NewServer creates a new Server from an implementation of View_Handler_Server.
func View_Handler_NewServer(s View_Handler_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(View_Handler_Methods(nil, s), s, c)
}

// View_Handler_ServerToClient creates a new Client from an implementation of View_Handler_Server.
// The caller is responsible for calling Release on the returned Client.
func View_Handler_ServerToClient(s View_Handler_Server) View_Handler {
	return View_Handler(capnp.NewClient(View_Handler_NewServer(s)))
}

// View_Handler_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func View_Handler_Methods(methods []server.Method, s View_Handler_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xee93a663b2a23c03,
			MethodID:      0,
			InterfaceName: "cluster.capnp:View.Handler",
			MethodName:    "recv",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Recv(ctx, View_Handler_recv{call})
		},
	})

	return methods
}

// View_Handler_recv holds the state for a server call to View_Handler.recv.
// See server.Call for documentation.
type View_Handler_recv struct {
	*server.Call
}

// Args returns the call's arguments.
func (c View_Handler_recv) Args() View_Handler_recv_Params {
	return View_Handler_recv_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c View_Handler_recv) AllocResults() (stream.StreamResult, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return stream.StreamResult(r), err
}

// View_Handler_List is a list of View_Handler.
type View_Handler_List = capnp.CapList[View_Handler]

// NewView_Handler creates a new list of View_Handler.
func NewView_Handler_List(s *capnp.Segment, sz int32) (View_Handler_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[View_Handler](l), err
}

type View_Handler_recv_Params capnp.Struct

// View_Handler_recv_Params_TypeID is the unique identifier for the type View_Handler_recv_Params.
const View_Handler_recv_Params_TypeID = 0x8eb96dceb6a99ebd

func NewView_Handler_recv_Params(s *capnp.Segment) (View_Handler_recv_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_Handler_recv_Params(st), err
}

func NewRootView_Handler_recv_Params(s *capnp.Segment) (View_Handler_recv_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_Handler_recv_Params(st), err
}

func ReadRootView_Handler_recv_Params(msg *capnp.Message) (View_Handler_recv_Params, error) {
	root, err := msg.Root()
	return View_Handler_recv_Params(root.Struct()), err
}

func (s View_Handler_recv_Params) String() string {
	str, _ := text.Marshal(0x8eb96dceb6a99ebd, capnp.Struct(s))
	return str
}

func (s View_Handler_recv_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_Handler_recv_Params) DecodeFromPtr(p capnp.Ptr) View_Handler_recv_Params {
	return View_Handler_recv_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_Handler_recv_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_Handler_recv_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_Handler_recv_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_Handler_recv_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_Handler_recv_Params) Record() (View_Record, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return View_Record(p.Struct()), err
}

func (s View_Handler_recv_Params) HasRecord() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Handler_recv_Params) SetRecord(v View_Record) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewRecord sets the record field to a newly
// allocated View_Record struct, preferring placement in s's segment.
func (s View_Handler_recv_Params) NewRecord() (View_Record, error) {
	ss, err := NewView_Record(capnp.Struct(s).Segment())
	if err != nil {
		return View_Record{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// View_Handler_recv_Params_List is a list of View_Handler_recv_Params.
type View_Handler_recv_Params_List = capnp.StructList[View_Handler_recv_Params]

// NewView_Handler_recv_Params creates a new list of View_Handler_recv_Params.
func NewView_Handler_recv_Params_List(s *capnp.Segment, sz int32) (View_Handler_recv_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[View_Handler_recv_Params](l), err
}

// View_Handler_recv_Params_Future is a wrapper for a View_Handler_recv_Params promised by a client call.
type View_Handler_recv_Params_Future struct{ *capnp.Future }

func (f View_Handler_recv_Params_Future) Struct() (View_Handler_recv_Params, error) {
	p, err := f.Future.Ptr()
	return View_Handler_recv_Params(p.Struct()), err
}
func (p View_Handler_recv_Params_Future) Record() View_Record_Future {
	return View_Record_Future{Future: p.Future.Field(0, nil)}
}

type View_Selector capnp.Struct
type View_Selector_Which uint16

const (
	View_Selector_Which_all   View_Selector_Which = 0
	View_Selector_Which_match View_Selector_Which = 1
	View_Selector_Which_from  View_Selector_Which = 2
)

func (w View_Selector_Which) String() string {
	const s = "allmatchfrom"
	switch w {
	case View_Selector_Which_all:
		return s[0:3]
	case View_Selector_Which_match:
		return s[3:8]
	case View_Selector_Which_from:
		return s[8:12]

	}
	return "View_Selector_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// View_Selector_TypeID is the unique identifier for the type View_Selector.
const View_Selector_TypeID = 0xb2029ff7b712d18a

func NewView_Selector(s *capnp.Segment) (View_Selector, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return View_Selector(st), err
}

func NewRootView_Selector(s *capnp.Segment) (View_Selector, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return View_Selector(st), err
}

func ReadRootView_Selector(msg *capnp.Message) (View_Selector, error) {
	root, err := msg.Root()
	return View_Selector(root.Struct()), err
}

func (s View_Selector) String() string {
	str, _ := text.Marshal(0xb2029ff7b712d18a, capnp.Struct(s))
	return str
}

func (s View_Selector) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_Selector) DecodeFromPtr(p capnp.Ptr) View_Selector {
	return View_Selector(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_Selector) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s View_Selector) Which() View_Selector_Which {
	return View_Selector_Which(capnp.Struct(s).Uint16(0))
}
func (s View_Selector) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_Selector) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_Selector) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_Selector) SetAll() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s View_Selector) Match() (View_Index, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != match")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return View_Index(p.Struct()), err
}

func (s View_Selector) HasMatch() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Selector) SetMatch(v View_Index) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewMatch sets the match field to a newly
// allocated View_Index struct, preferring placement in s's segment.
func (s View_Selector) NewMatch() (View_Index, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewView_Index(capnp.Struct(s).Segment())
	if err != nil {
		return View_Index{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s View_Selector) From() (View_Index, error) {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != from")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return View_Index(p.Struct()), err
}

func (s View_Selector) HasFrom() bool {
	if capnp.Struct(s).Uint16(0) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Selector) SetFrom(v View_Index) error {
	capnp.Struct(s).SetUint16(0, 2)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewFrom sets the from field to a newly
// allocated View_Index struct, preferring placement in s's segment.
func (s View_Selector) NewFrom() (View_Index, error) {
	capnp.Struct(s).SetUint16(0, 2)
	ss, err := NewView_Index(capnp.Struct(s).Segment())
	if err != nil {
		return View_Index{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// View_Selector_List is a list of View_Selector.
type View_Selector_List = capnp.StructList[View_Selector]

// NewView_Selector creates a new list of View_Selector.
func NewView_Selector_List(s *capnp.Segment, sz int32) (View_Selector_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[View_Selector](l), err
}

// View_Selector_Future is a wrapper for a View_Selector promised by a client call.
type View_Selector_Future struct{ *capnp.Future }

func (f View_Selector_Future) Struct() (View_Selector, error) {
	p, err := f.Future.Ptr()
	return View_Selector(p.Struct()), err
}
func (p View_Selector_Future) Match() View_Index_Future {
	return View_Index_Future{Future: p.Future.Field(0, nil)}
}
func (p View_Selector_Future) From() View_Index_Future {
	return View_Index_Future{Future: p.Future.Field(0, nil)}
}

type View_Constraint capnp.Struct
type View_Constraint_Which uint16

const (
	View_Constraint_Which_limit View_Constraint_Which = 0
	View_Constraint_Which_to    View_Constraint_Which = 1
)

func (w View_Constraint_Which) String() string {
	const s = "limitto"
	switch w {
	case View_Constraint_Which_limit:
		return s[0:5]
	case View_Constraint_Which_to:
		return s[5:7]

	}
	return "View_Constraint_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// View_Constraint_TypeID is the unique identifier for the type View_Constraint.
const View_Constraint_TypeID = 0xab133d2062f6cc53

func NewView_Constraint(s *capnp.Segment) (View_Constraint, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return View_Constraint(st), err
}

func NewRootView_Constraint(s *capnp.Segment) (View_Constraint, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return View_Constraint(st), err
}

func ReadRootView_Constraint(msg *capnp.Message) (View_Constraint, error) {
	root, err := msg.Root()
	return View_Constraint(root.Struct()), err
}

func (s View_Constraint) String() string {
	str, _ := text.Marshal(0xab133d2062f6cc53, capnp.Struct(s))
	return str
}

func (s View_Constraint) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_Constraint) DecodeFromPtr(p capnp.Ptr) View_Constraint {
	return View_Constraint(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_Constraint) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s View_Constraint) Which() View_Constraint_Which {
	return View_Constraint_Which(capnp.Struct(s).Uint16(8))
}
func (s View_Constraint) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_Constraint) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_Constraint) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_Constraint) Limit() uint64 {
	if capnp.Struct(s).Uint16(8) != 0 {
		panic("Which() != limit")
	}
	return capnp.Struct(s).Uint64(0)
}

func (s View_Constraint) SetLimit(v uint64) {
	capnp.Struct(s).SetUint16(8, 0)
	capnp.Struct(s).SetUint64(0, v)
}

func (s View_Constraint) To() (View_Index, error) {
	if capnp.Struct(s).Uint16(8) != 1 {
		panic("Which() != to")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return View_Index(p.Struct()), err
}

func (s View_Constraint) HasTo() bool {
	if capnp.Struct(s).Uint16(8) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Constraint) SetTo(v View_Index) error {
	capnp.Struct(s).SetUint16(8, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewTo sets the to field to a newly
// allocated View_Index struct, preferring placement in s's segment.
func (s View_Constraint) NewTo() (View_Index, error) {
	capnp.Struct(s).SetUint16(8, 1)
	ss, err := NewView_Index(capnp.Struct(s).Segment())
	if err != nil {
		return View_Index{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// View_Constraint_List is a list of View_Constraint.
type View_Constraint_List = capnp.StructList[View_Constraint]

// NewView_Constraint creates a new list of View_Constraint.
func NewView_Constraint_List(s *capnp.Segment, sz int32) (View_Constraint_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[View_Constraint](l), err
}

// View_Constraint_Future is a wrapper for a View_Constraint promised by a client call.
type View_Constraint_Future struct{ *capnp.Future }

func (f View_Constraint_Future) Struct() (View_Constraint, error) {
	p, err := f.Future.Ptr()
	return View_Constraint(p.Struct()), err
}
func (p View_Constraint_Future) To() View_Index_Future {
	return View_Index_Future{Future: p.Future.Field(0, nil)}
}

type View_Index capnp.Struct
type View_Index_Which uint16

const (
	View_Index_Which_peer   View_Index_Which = 0
	View_Index_Which_server View_Index_Which = 1
	View_Index_Which_host   View_Index_Which = 2
	View_Index_Which_meta   View_Index_Which = 3
)

func (w View_Index_Which) String() string {
	const s = "peerserverhostmeta"
	switch w {
	case View_Index_Which_peer:
		return s[0:4]
	case View_Index_Which_server:
		return s[4:10]
	case View_Index_Which_host:
		return s[10:14]
	case View_Index_Which_meta:
		return s[14:18]

	}
	return "View_Index_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// View_Index_TypeID is the unique identifier for the type View_Index.
const View_Index_TypeID = 0xcc2d04cc26d4f6a5

func NewView_Index(s *capnp.Segment) (View_Index, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return View_Index(st), err
}

func NewRootView_Index(s *capnp.Segment) (View_Index, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return View_Index(st), err
}

func ReadRootView_Index(msg *capnp.Message) (View_Index, error) {
	root, err := msg.Root()
	return View_Index(root.Struct()), err
}

func (s View_Index) String() string {
	str, _ := text.Marshal(0xcc2d04cc26d4f6a5, capnp.Struct(s))
	return str
}

func (s View_Index) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_Index) DecodeFromPtr(p capnp.Ptr) View_Index {
	return View_Index(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_Index) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s View_Index) Which() View_Index_Which {
	return View_Index_Which(capnp.Struct(s).Uint16(2))
}
func (s View_Index) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_Index) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_Index) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_Index) Prefix() bool {
	return capnp.Struct(s).Bit(0)
}

func (s View_Index) SetPrefix(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

func (s View_Index) Peer() (string, error) {
	if capnp.Struct(s).Uint16(2) != 0 {
		panic("Which() != peer")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s View_Index) HasPeer() bool {
	if capnp.Struct(s).Uint16(2) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Index) PeerBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s View_Index) SetPeer(v string) error {
	capnp.Struct(s).SetUint16(2, 0)
	return capnp.Struct(s).SetText(0, v)
}

func (s View_Index) Server() ([]byte, error) {
	if capnp.Struct(s).Uint16(2) != 1 {
		panic("Which() != server")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s View_Index) HasServer() bool {
	if capnp.Struct(s).Uint16(2) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Index) SetServer(v []byte) error {
	capnp.Struct(s).SetUint16(2, 1)
	return capnp.Struct(s).SetData(0, v)
}

func (s View_Index) Host() (string, error) {
	if capnp.Struct(s).Uint16(2) != 2 {
		panic("Which() != host")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s View_Index) HasHost() bool {
	if capnp.Struct(s).Uint16(2) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Index) HostBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s View_Index) SetHost(v string) error {
	capnp.Struct(s).SetUint16(2, 2)
	return capnp.Struct(s).SetText(0, v)
}

func (s View_Index) Meta() (string, error) {
	if capnp.Struct(s).Uint16(2) != 3 {
		panic("Which() != meta")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s View_Index) HasMeta() bool {
	if capnp.Struct(s).Uint16(2) != 3 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Index) MetaBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s View_Index) SetMeta(v string) error {
	capnp.Struct(s).SetUint16(2, 3)
	return capnp.Struct(s).SetText(0, v)
}

// View_Index_List is a list of View_Index.
type View_Index_List = capnp.StructList[View_Index]

// NewView_Index creates a new list of View_Index.
func NewView_Index_List(s *capnp.Segment, sz int32) (View_Index_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[View_Index](l), err
}

// View_Index_Future is a wrapper for a View_Index promised by a client call.
type View_Index_Future struct{ *capnp.Future }

func (f View_Index_Future) Struct() (View_Index, error) {
	p, err := f.Future.Ptr()
	return View_Index(p.Struct()), err
}

type View_Record capnp.Struct

// View_Record_TypeID is the unique identifier for the type View_Record.
const View_Record_TypeID = 0xcdcf42beb2537d20

func NewView_Record(s *capnp.Segment) (View_Record, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return View_Record(st), err
}

func NewRootView_Record(s *capnp.Segment) (View_Record, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return View_Record(st), err
}

func ReadRootView_Record(msg *capnp.Message) (View_Record, error) {
	root, err := msg.Root()
	return View_Record(root.Struct()), err
}

func (s View_Record) String() string {
	str, _ := text.Marshal(0xcdcf42beb2537d20, capnp.Struct(s))
	return str
}

func (s View_Record) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_Record) DecodeFromPtr(p capnp.Ptr) View_Record {
	return View_Record(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_Record) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_Record) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_Record) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_Record) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_Record) Peer() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s View_Record) HasPeer() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s View_Record) PeerBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s View_Record) SetPeer(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s View_Record) Server() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s View_Record) SetServer(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s View_Record) Seq() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s View_Record) SetSeq(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s View_Record) Heartbeat() (Heartbeat, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Heartbeat(p.Struct()), err
}

func (s View_Record) HasHeartbeat() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s View_Record) SetHeartbeat(v Heartbeat) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewHeartbeat sets the heartbeat field to a newly
// allocated Heartbeat struct, preferring placement in s's segment.
func (s View_Record) NewHeartbeat() (Heartbeat, error) {
	ss, err := NewHeartbeat(capnp.Struct(s).Segment())
	if err != nil {
		return Heartbeat{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// View_Record_List is a list of View_Record.
type View_Record_List = capnp.StructList[View_Record]

// NewView_Record creates a new list of View_Record.
func NewView_Record_List(s *capnp.Segment, sz int32) (View_Record_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[View_Record](l), err
}

// View_Record_Future is a wrapper for a View_Record promised by a client call.
type View_Record_Future struct{ *capnp.Future }

func (f View_Record_Future) Struct() (View_Record, error) {
	p, err := f.Future.Ptr()
	return View_Record(p.Struct()), err
}
func (p View_Record_Future) Heartbeat() Heartbeat_Future {
	return Heartbeat_Future{Future: p.Future.Field(1, nil)}
}

type View_MaybeRecord capnp.Struct
type View_MaybeRecord_Which uint16

const (
	View_MaybeRecord_Which_nothing View_MaybeRecord_Which = 0
	View_MaybeRecord_Which_just    View_MaybeRecord_Which = 1
)

func (w View_MaybeRecord_Which) String() string {
	const s = "nothingjust"
	switch w {
	case View_MaybeRecord_Which_nothing:
		return s[0:7]
	case View_MaybeRecord_Which_just:
		return s[7:11]

	}
	return "View_MaybeRecord_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// View_MaybeRecord_TypeID is the unique identifier for the type View_MaybeRecord.
const View_MaybeRecord_TypeID = 0xd6a4f298bc0e2304

func NewView_MaybeRecord(s *capnp.Segment) (View_MaybeRecord, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return View_MaybeRecord(st), err
}

func NewRootView_MaybeRecord(s *capnp.Segment) (View_MaybeRecord, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return View_MaybeRecord(st), err
}

func ReadRootView_MaybeRecord(msg *capnp.Message) (View_MaybeRecord, error) {
	root, err := msg.Root()
	return View_MaybeRecord(root.Struct()), err
}

func (s View_MaybeRecord) String() string {
	str, _ := text.Marshal(0xd6a4f298bc0e2304, capnp.Struct(s))
	return str
}

func (s View_MaybeRecord) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_MaybeRecord) DecodeFromPtr(p capnp.Ptr) View_MaybeRecord {
	return View_MaybeRecord(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_MaybeRecord) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s View_MaybeRecord) Which() View_MaybeRecord_Which {
	return View_MaybeRecord_Which(capnp.Struct(s).Uint16(0))
}
func (s View_MaybeRecord) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_MaybeRecord) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_MaybeRecord) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_MaybeRecord) SetNothing() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s View_MaybeRecord) Just() (View_Record, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != just")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return View_Record(p.Struct()), err
}

func (s View_MaybeRecord) HasJust() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s View_MaybeRecord) SetJust(v View_Record) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewJust sets the just field to a newly
// allocated View_Record struct, preferring placement in s's segment.
func (s View_MaybeRecord) NewJust() (View_Record, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewView_Record(capnp.Struct(s).Segment())
	if err != nil {
		return View_Record{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// View_MaybeRecord_List is a list of View_MaybeRecord.
type View_MaybeRecord_List = capnp.StructList[View_MaybeRecord]

// NewView_MaybeRecord creates a new list of View_MaybeRecord.
func NewView_MaybeRecord_List(s *capnp.Segment, sz int32) (View_MaybeRecord_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[View_MaybeRecord](l), err
}

// View_MaybeRecord_Future is a wrapper for a View_MaybeRecord promised by a client call.
type View_MaybeRecord_Future struct{ *capnp.Future }

func (f View_MaybeRecord_Future) Struct() (View_MaybeRecord, error) {
	p, err := f.Future.Ptr()
	return View_MaybeRecord(p.Struct()), err
}
func (p View_MaybeRecord_Future) Just() View_Record_Future {
	return View_Record_Future{Future: p.Future.Field(0, nil)}
}

type View_lookup_Params capnp.Struct

// View_lookup_Params_TypeID is the unique identifier for the type View_lookup_Params.
const View_lookup_Params_TypeID = 0xd929e054f82b286c

func NewView_lookup_Params(s *capnp.Segment) (View_lookup_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return View_lookup_Params(st), err
}

func NewRootView_lookup_Params(s *capnp.Segment) (View_lookup_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return View_lookup_Params(st), err
}

func ReadRootView_lookup_Params(msg *capnp.Message) (View_lookup_Params, error) {
	root, err := msg.Root()
	return View_lookup_Params(root.Struct()), err
}

func (s View_lookup_Params) String() string {
	str, _ := text.Marshal(0xd929e054f82b286c, capnp.Struct(s))
	return str
}

func (s View_lookup_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_lookup_Params) DecodeFromPtr(p capnp.Ptr) View_lookup_Params {
	return View_lookup_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_lookup_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_lookup_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_lookup_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_lookup_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_lookup_Params) Selector() (View_Selector, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return View_Selector(p.Struct()), err
}

func (s View_lookup_Params) HasSelector() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s View_lookup_Params) SetSelector(v View_Selector) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSelector sets the selector field to a newly
// allocated View_Selector struct, preferring placement in s's segment.
func (s View_lookup_Params) NewSelector() (View_Selector, error) {
	ss, err := NewView_Selector(capnp.Struct(s).Segment())
	if err != nil {
		return View_Selector{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s View_lookup_Params) Constraints() (View_Constraint_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return View_Constraint_List(p.List()), err
}

func (s View_lookup_Params) HasConstraints() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s View_lookup_Params) SetConstraints(v View_Constraint_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewConstraints sets the constraints field to a newly
// allocated View_Constraint_List, preferring placement in s's segment.
func (s View_lookup_Params) NewConstraints(n int32) (View_Constraint_List, error) {
	l, err := NewView_Constraint_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return View_Constraint_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// View_lookup_Params_List is a list of View_lookup_Params.
type View_lookup_Params_List = capnp.StructList[View_lookup_Params]

// NewView_lookup_Params creates a new list of View_lookup_Params.
func NewView_lookup_Params_List(s *capnp.Segment, sz int32) (View_lookup_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[View_lookup_Params](l), err
}

// View_lookup_Params_Future is a wrapper for a View_lookup_Params promised by a client call.
type View_lookup_Params_Future struct{ *capnp.Future }

func (f View_lookup_Params_Future) Struct() (View_lookup_Params, error) {
	p, err := f.Future.Ptr()
	return View_lookup_Params(p.Struct()), err
}
func (p View_lookup_Params_Future) Selector() View_Selector_Future {
	return View_Selector_Future{Future: p.Future.Field(0, nil)}
}

type View_lookup_Results capnp.Struct

// View_lookup_Results_TypeID is the unique identifier for the type View_lookup_Results.
const View_lookup_Results_TypeID = 0xe6df611247a8fc13

func NewView_lookup_Results(s *capnp.Segment) (View_lookup_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_lookup_Results(st), err
}

func NewRootView_lookup_Results(s *capnp.Segment) (View_lookup_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_lookup_Results(st), err
}

func ReadRootView_lookup_Results(msg *capnp.Message) (View_lookup_Results, error) {
	root, err := msg.Root()
	return View_lookup_Results(root.Struct()), err
}

func (s View_lookup_Results) String() string {
	str, _ := text.Marshal(0xe6df611247a8fc13, capnp.Struct(s))
	return str
}

func (s View_lookup_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_lookup_Results) DecodeFromPtr(p capnp.Ptr) View_lookup_Results {
	return View_lookup_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_lookup_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_lookup_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_lookup_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_lookup_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_lookup_Results) Result() (View_MaybeRecord, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return View_MaybeRecord(p.Struct()), err
}

func (s View_lookup_Results) HasResult() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s View_lookup_Results) SetResult(v View_MaybeRecord) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewResult sets the result field to a newly
// allocated View_MaybeRecord struct, preferring placement in s's segment.
func (s View_lookup_Results) NewResult() (View_MaybeRecord, error) {
	ss, err := NewView_MaybeRecord(capnp.Struct(s).Segment())
	if err != nil {
		return View_MaybeRecord{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// View_lookup_Results_List is a list of View_lookup_Results.
type View_lookup_Results_List = capnp.StructList[View_lookup_Results]

// NewView_lookup_Results creates a new list of View_lookup_Results.
func NewView_lookup_Results_List(s *capnp.Segment, sz int32) (View_lookup_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[View_lookup_Results](l), err
}

// View_lookup_Results_Future is a wrapper for a View_lookup_Results promised by a client call.
type View_lookup_Results_Future struct{ *capnp.Future }

func (f View_lookup_Results_Future) Struct() (View_lookup_Results, error) {
	p, err := f.Future.Ptr()
	return View_lookup_Results(p.Struct()), err
}
func (p View_lookup_Results_Future) Result() View_MaybeRecord_Future {
	return View_MaybeRecord_Future{Future: p.Future.Field(0, nil)}
}

type View_iter_Params capnp.Struct

// View_iter_Params_TypeID is the unique identifier for the type View_iter_Params.
const View_iter_Params_TypeID = 0xf495a555c9344000

func NewView_iter_Params(s *capnp.Segment) (View_iter_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return View_iter_Params(st), err
}

func NewRootView_iter_Params(s *capnp.Segment) (View_iter_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return View_iter_Params(st), err
}

func ReadRootView_iter_Params(msg *capnp.Message) (View_iter_Params, error) {
	root, err := msg.Root()
	return View_iter_Params(root.Struct()), err
}

func (s View_iter_Params) String() string {
	str, _ := text.Marshal(0xf495a555c9344000, capnp.Struct(s))
	return str
}

func (s View_iter_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_iter_Params) DecodeFromPtr(p capnp.Ptr) View_iter_Params {
	return View_iter_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_iter_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_iter_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_iter_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_iter_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_iter_Params) Handler() View_Handler {
	p, _ := capnp.Struct(s).Ptr(0)
	return View_Handler(p.Interface().Client())
}

func (s View_iter_Params) HasHandler() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s View_iter_Params) SetHandler(v View_Handler) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

func (s View_iter_Params) Selector() (View_Selector, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return View_Selector(p.Struct()), err
}

func (s View_iter_Params) HasSelector() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s View_iter_Params) SetSelector(v View_Selector) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewSelector sets the selector field to a newly
// allocated View_Selector struct, preferring placement in s's segment.
func (s View_iter_Params) NewSelector() (View_Selector, error) {
	ss, err := NewView_Selector(capnp.Struct(s).Segment())
	if err != nil {
		return View_Selector{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s View_iter_Params) Constraints() (View_Constraint_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return View_Constraint_List(p.List()), err
}

func (s View_iter_Params) HasConstraints() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s View_iter_Params) SetConstraints(v View_Constraint_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewConstraints sets the constraints field to a newly
// allocated View_Constraint_List, preferring placement in s's segment.
func (s View_iter_Params) NewConstraints(n int32) (View_Constraint_List, error) {
	l, err := NewView_Constraint_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return View_Constraint_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}

// View_iter_Params_List is a list of View_iter_Params.
type View_iter_Params_List = capnp.StructList[View_iter_Params]

// NewView_iter_Params creates a new list of View_iter_Params.
func NewView_iter_Params_List(s *capnp.Segment, sz int32) (View_iter_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[View_iter_Params](l), err
}

// View_iter_Params_Future is a wrapper for a View_iter_Params promised by a client call.
type View_iter_Params_Future struct{ *capnp.Future }

func (f View_iter_Params_Future) Struct() (View_iter_Params, error) {
	p, err := f.Future.Ptr()
	return View_iter_Params(p.Struct()), err
}
func (p View_iter_Params_Future) Handler() View_Handler {
	return View_Handler(p.Future.Field(0, nil).Client())
}

func (p View_iter_Params_Future) Selector() View_Selector_Future {
	return View_Selector_Future{Future: p.Future.Field(1, nil)}
}

type View_iter_Results capnp.Struct

// View_iter_Results_TypeID is the unique identifier for the type View_iter_Results.
const View_iter_Results_TypeID = 0xe54acc44b61fd7ef

func NewView_iter_Results(s *capnp.Segment) (View_iter_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return View_iter_Results(st), err
}

func NewRootView_iter_Results(s *capnp.Segment) (View_iter_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return View_iter_Results(st), err
}

func ReadRootView_iter_Results(msg *capnp.Message) (View_iter_Results, error) {
	root, err := msg.Root()
	return View_iter_Results(root.Struct()), err
}

func (s View_iter_Results) String() string {
	str, _ := text.Marshal(0xe54acc44b61fd7ef, capnp.Struct(s))
	return str
}

func (s View_iter_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_iter_Results) DecodeFromPtr(p capnp.Ptr) View_iter_Results {
	return View_iter_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_iter_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_iter_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_iter_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_iter_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// View_iter_Results_List is a list of View_iter_Results.
type View_iter_Results_List = capnp.StructList[View_iter_Results]

// NewView_iter_Results creates a new list of View_iter_Results.
func NewView_iter_Results_List(s *capnp.Segment, sz int32) (View_iter_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[View_iter_Results](l), err
}

// View_iter_Results_Future is a wrapper for a View_iter_Results promised by a client call.
type View_iter_Results_Future struct{ *capnp.Future }

func (f View_iter_Results_Future) Struct() (View_iter_Results, error) {
	p, err := f.Future.Ptr()
	return View_iter_Results(p.Struct()), err
}

type View_reverse_Params capnp.Struct

// View_reverse_Params_TypeID is the unique identifier for the type View_reverse_Params.
const View_reverse_Params_TypeID = 0x8b1fd983f1df482d

func NewView_reverse_Params(s *capnp.Segment) (View_reverse_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return View_reverse_Params(st), err
}

func NewRootView_reverse_Params(s *capnp.Segment) (View_reverse_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return View_reverse_Params(st), err
}

func ReadRootView_reverse_Params(msg *capnp.Message) (View_reverse_Params, error) {
	root, err := msg.Root()
	return View_reverse_Params(root.Struct()), err
}

func (s View_reverse_Params) String() string {
	str, _ := text.Marshal(0x8b1fd983f1df482d, capnp.Struct(s))
	return str
}

func (s View_reverse_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_reverse_Params) DecodeFromPtr(p capnp.Ptr) View_reverse_Params {
	return View_reverse_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_reverse_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_reverse_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_reverse_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_reverse_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// View_reverse_Params_List is a list of View_reverse_Params.
type View_reverse_Params_List = capnp.StructList[View_reverse_Params]

// NewView_reverse_Params creates a new list of View_reverse_Params.
func NewView_reverse_Params_List(s *capnp.Segment, sz int32) (View_reverse_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[View_reverse_Params](l), err
}

// View_reverse_Params_Future is a wrapper for a View_reverse_Params promised by a client call.
type View_reverse_Params_Future struct{ *capnp.Future }

func (f View_reverse_Params_Future) Struct() (View_reverse_Params, error) {
	p, err := f.Future.Ptr()
	return View_reverse_Params(p.Struct()), err
}

type View_reverse_Results capnp.Struct

// View_reverse_Results_TypeID is the unique identifier for the type View_reverse_Results.
const View_reverse_Results_TypeID = 0xcc7efefbb528cd6c

func NewView_reverse_Results(s *capnp.Segment) (View_reverse_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_reverse_Results(st), err
}

func NewRootView_reverse_Results(s *capnp.Segment) (View_reverse_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return View_reverse_Results(st), err
}

func ReadRootView_reverse_Results(msg *capnp.Message) (View_reverse_Results, error) {
	root, err := msg.Root()
	return View_reverse_Results(root.Struct()), err
}

func (s View_reverse_Results) String() string {
	str, _ := text.Marshal(0xcc7efefbb528cd6c, capnp.Struct(s))
	return str
}

func (s View_reverse_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (View_reverse_Results) DecodeFromPtr(p capnp.Ptr) View_reverse_Results {
	return View_reverse_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s View_reverse_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s View_reverse_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s View_reverse_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s View_reverse_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s View_reverse_Results) View() View {
	p, _ := capnp.Struct(s).Ptr(0)
	return View(p.Interface().Client())
}

func (s View_reverse_Results) HasView() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s View_reverse_Results) SetView(v View) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// View_reverse_Results_List is a list of View_reverse_Results.
type View_reverse_Results_List = capnp.StructList[View_reverse_Results]

// NewView_reverse_Results creates a new list of View_reverse_Results.
func NewView_reverse_Results_List(s *capnp.Segment, sz int32) (View_reverse_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[View_reverse_Results](l), err
}

// View_reverse_Results_Future is a wrapper for a View_reverse_Results promised by a client call.
type View_reverse_Results_Future struct{ *capnp.Future }

func (f View_reverse_Results_Future) Struct() (View_reverse_Results, error) {
	p, err := f.Future.Ptr()
	return View_reverse_Results(p.Struct()), err
}
func (p View_reverse_Results_Future) View() View {
	return View(p.Future.Field(0, nil).Client())
}

const schema_fcf6ac08e448a6ac = "x\xda\xacVol[W\x15?\xe7\xde\x97\xbc\x94\xf9" +
	"\xd9\xbe\xbe\xafh\xdd4y-\x094\x86D];\x81" +
	"j19\x0b\x0dI\xc3*\xe5\xd6\x1b\x82\x091\x1c\xe7" +
	".1\xd8\xefy\xef='\xa9\xb4\x12*Vi\x0cV" +
	"\xc6\x9fJ\xa3b \xa1ub0\xa9\xa2hCE\xdb" +
	"\x04\xfb\x00\x1a\xa4\x9b\xd8\x1fP\x11P\x8a\xba\xed\xd3F" +
	"[\xb1\x0e\x95\xac\x0f\xdd\xe7\xf7\xfc\x1c\xdb\x0b_\xf8\xf6" +
	"|\xef\xf19\xbfs\xce\xefw\xce\xdd\xb1\xbb\x7fL\xbb" +
	"\xc9xq\x0b\x90\xe2G\xb0\xaf\xdf?6\xb8v\xe7\xae" +
	"\x0b7<\x00,I\xfd'\x1e\x9b:?\xf0\xc4\xe55" +
	"\x00\xe4\xa7\x13\xc7\xf8\xab\x89y\x00>d\xfc\x96?b" +
	"\xe8\x00\xfe\xc8\xd4\xd9\x8b_=\x93\xfd:0\x8e\x00\x9a" +
	"\x0e\xb0\xeb\xb0\x91A\xd0\xfcg~\xf0\xf8S/\xd4N" +
	"\x1d\x01v=\x02\xf4\xa1\xba\xaa\x19y\x04\xe4\x0d\xa3\x00" +
	"\xe8\xbf\xfd\xcam\x87\x8f|\xfb3\xdfl\xfe\xb5\xafO" +
	"\x19\x1c5\xde\x87\x80\xbb\x1e1\xb2\x08\xe8\xeb/\xdf5" +
	"\xb7\xf6\xec\xbdG\xbb\x90<\x99<\xc6\x9fI\xea\x00\xfc" +
	"Tr\x92\x9fS_\xfe\xf9S\x8d\xe2\xa7\x9e\xd3\x1e\x0d" +
	"\xdd\x05\xf1\x9eO\x12\x15\xeftR\xc5\xbb\xf1\x9d\x8f>" +
	"\xac\xdf\xe3=\x0e\"\x89$v\xd7G\x94\x9f7\x93\xcf" +
	"\xf1\xb7\x03\x8f\x17\x93o\x00\xfa\xc5\xd5\xcb\xb37\xde\xc2" +
	"\x7f\x0a\x82#\x89K2\x81:A\x8d\xbf\x9a\xba\xc4\xcf" +
	"\xa5\x94\xf5_SK\x80\xfe\x03\x7f\xc8\xfc\xe2\x9d\x1f\x92" +
	"\x93\xca\x1a\xd7YS\x00\xbe;\xfd\x0f>\x91V\xd6\xb7" +
	"\xa6O\x00\xfa\x1f\x9a\xec\x7f\xf9\xfd\x89\xa1\x93\xc06\xb7" +
	"\x90\x9eI\xab\xc4\xf9\xb9\xb4Bz\xfc\xf2+\x1f\\\xd5" +
	"FV\xbb\xddi\x88\x1c\xd9\xef\xb8\xc1\xd4\x9f6\xb1\xa0" +
	"L\xd5\xd3\xdb\x9f\xfc\xcf\xd5/\xaf\xb6g\xbe%s\x9d" +
	"\xf2\xb75\x13d~\xb0x\xf2\xd9\xf1\x17Ow$\xd3" +
	"\xcc\xfc\xd6\xccK|_F}\xed\xcd\xa8\xcc\xb5\x0f$" +
	"\x9f~\xf8\xd2\xa3\x7f\xec\x0eN\x00\xf8V~\x85\x8fp" +
	"e=\xccU\xe6\xd5\xed\x1f\xfe\xf7\xed\x7f\x1f>\x13\xc6" +
	"&\x01\x01x\x90\xcb\x83\x81\xc1?\xff\x94}j\xcf\xea" +
	"\xf4km\x04A\x93(\x82\xf0\xb5\x1fOfJg_" +
	"o\x87\xfd\x1a\xcf\xa8\xbf\xbe\xc9\x15l\xfa\xf1\x1f\x9d," +
	"?\xf6\x9d\xb7\x80q\x1a\x03\x01\xe4\x86\xf9g\xbe\xc5T" +
	" 6\x9b\x93\xfc\x16\xf5u\xf6\x8d+\x7f\xf9\x8ds\xcd" +
	"\x85\xb6\x92\x0e\x99\x81\xaf\x11S\xf9z\xfa\xd2\xaf_\xd8" +
	"s\xee\xd2\xc5.*\x09\xf3'\xfc\xb3\x81\xaf;\xccI" +
	"~P}]\x1d\xbb\xf9\xf9;\x8e\x1f\xfdW\x13\x17U" +
	"w\xd2\xbc\x02\xc8+\xe6\x09\xf0\xc1\x87\xa2_\xae6\\" +
	"O:\xa3X.\xd5\xadz\xfe\xd3\x15*\x97\xc4\xb5\xd8" +
	"\x8eyx<\xa6\x05\x1b\x9a\x8e\x19\xc5\x86\xee\x8c;\xcc" +
	"\x86v\xc6\xeda[\xf3q\xf9\xd9\x0d\xb3+S%k" +
	"\xae*\x1d\xbf(\xab\xb2\xec\xd9\x0e\x00\xf8\x9f\xb0-\xd7" +
	"sJ\x15\xa0\x96\x97\xddk\xcd\xc9\xe5\xc2~Y\xb6\x9d" +
	"9\x7f_\xe9\xc0\xac\xdc/\xcb\xa0\xdb\xce\x9cH\xd0>" +
	"\x80V\x7f0\xaa6\x13y lBG\x8c\xd2lk" +
	"\xd1\xee\x1c\x106\xa2#i\xe9\x1a#r\xb1\xad\xe3@" +
	"\xd8f\xbdP\xb5\xed/5\xeac\x98\xaax\xd2\x19\xc3" +
	"\x15G.J\xc7\x95c8\x83\xd8\xaa\x0b\x8d\xea\"\x97" +
	"FC\x83\xc1\x99\x92S\xaa\xa1\xdb\xd3&Lt\xd4\x91" +
	"\xe5\xc5\xc1B`\xe9\x0a\x8dj\x00\x1a\x020#\x0f " +
	"\x06(\x0a\x93`\xc1\x09\xb2\xc5t\\7@LCW" +
	"\xf0)\xdb\xf5F\xab\xf6|\xc5\x1a\xdc/\xddF\xd5s" +
	"\x01\x84\xd9\xf2y0\x07 \x96)\x8a\xfb\x082D\x13" +
	"\xd5\xe1!\x15\xe8^\x8a\xe2~\x82\x8c\x10\x13\x09\x00;" +
	"\xac,\xbfBQ|\x83 \xa3\xd4D\x0a\xc0\xbe6\x0d" +
	" \xee\xa7(\xbeK\x90i\x9a\x89\x1a\x00\xfb\x96:|" +
	"\x88\xa2\xf8>\xc1\xd4bE.!k'.2\xc0B" +
	"\xbd1[l\xcc\"\xf3\xf3\xf6\xe2\xf5\xaf\xff|\xe6o" +
	"\xe1E\xca\xb1m\x0f\x99\xbf\xed\xcc\x91M\xe7?\x969" +
	"\x1f\x1e\xfb\x8e\x9c\xaf\xb8\x9es\x00\x00\x90\xf9\x9f\xfc\xfd" +
	"\x81\xb2\xad\xbf\xf5nt+\x97e\xb9\xd1d\x062\xff" +
	"\xa5\xc6\xa1\xe3\xbf\xfc\xfc\xe8\x89\xe8\xb6\x83\xa6S6u" +
	"\xbd\x19D\xa1\x05\xdc\x88&&F\x93\x98\xb1\x9d@X" +
	"\x9f\x9e\x0d\xaa\xd6\xb3\xa3mEmv\x09\xda\xdb4\x1e" +
	"\xb7i\xa5T.\xdb\x0dKe\xd4\xd2^\x07*\x12\xba" +
	"\x94%\xc7\x9b\x95%\x0f\x14\xb4t\xcb[i\x1b\x80\xf8" +
	"\x1cE\xb1\xd0\xd6 \xa9\x1a\xf4\x05\x8a\xa2J\x10\xc3\xfe" +
	"TT\x7f\xe6(\x8a\xba\xea\x0f6\xfbSS\x87\x0b\xcd" +
	"\xf6\xea\x9eW\xc5\x01 8\x00Xp\xa5\xb3(\x1d\xdc" +
	"\x04\x047\x01\xa6\x16l\xd7\xc3\x04\x10L\x00\xa6j\xd2" +
	"+a\x12p\x86bp\x96\xecF\x1b\xd05\xd0`\xd6" +
	")U\xac\xa0\x9c\x03TK\xf8~\x00zx'\x80\x18" +
	"\xa4(v\x104\xf0\xaa\xdfD=r\x1d\x80\xd8NQ" +
	"\xdcL0[\xad\xd4*^\x14\x9fz6\xa6\xe3q\xd0" +
	"\xc1\xe4\xf6\x98\xc1\x0c\xd0=\xdbQ\x11\x13q\xc4\x09U" +
	"\xa61\x8a\xe2\xb6\xf6\x88{\x15\x8e=\x14\xc5\x0cA\x83" +
	"\xbc\xeb7+\xb5O\x15e\x8a\xa2\xb8\x9d\xa0^\xaaV" +
	"\xa1?[+y\xe5\x85n\x08\xa9\xbb\x1d\xbb\xb6\x01\xb2" +
	"\x90\x0e\xc5\xca\xbc%\x9dQ\xb72\xdf\xe2\xc3:B\xec" +
	"\x8c\x09\x91\xb5l\xab,\xd1\x00\x82\xc6{\xa4\x18L3" +
	"\x08h\xd0\xa6\xd3|\xacS\x03\xfd0\xbfC\xb9X\xa8" +
	"\x06\xb9\x1a\xe6w8\x1f+\xd5\xa0*\xeb@\xaa\xca\xf6" +
	">\x8a\xe2!\x82\x86\xb6\xe67\xb5\xfa`.\x16p\xa1" +
	"\xee\xc8\xbb+\xcb\x88@\x10\x01Su)\x9d\x88\x14\x11" +
	"aB\xe0=\x08\x13\xfe\xd8p\xf8\x05\x13\x88z\xeb\x86" +
	"Z..\xce{\x0c\x8b\x9eU\x0a\xa6=\xceu\x88%" +
	"\x17\x8b\xa5\x97V\x18\xc1P,\xdbz\x89e?\x80\xa8" +
	"R\x14\xcb\xa4w\xf2![uW\xde\x13}\xfb\x0b\xa1" +
	"n\x01=5\x8c\xa3\xd7\xd5\x06\x14\x0e\x16T\xb8\xad:" +
	"u3\xdeS7\xb9X7+\x96\xed-T\xacy\xe8" +
	"O}\xb1\xe1z\xff{\xfe\x07!\x9b\xdb*\xe6\xe6@" +
	"\xabb\xc3\xd3\xb1\xef\xd6x\xb9i\x16@\xech\x8a\xc9" +
	"w\xe3\xad\x8b\xe9x\x99G\xd1\xa2=\xac[\x9e\x1b\x0d" +
	"\x8dt\xbc\xe6\x01\xd7\x8d\x0f\xbd\x0d\x94\xda\x9c\xad\x9d\x14" +
	"\x19t\x83nZ\xe0\x06\x8b0\xb8O\xc7o\x86\x0dj" +
	"\x1flX*\x9dx\xfcG\x0ft\xb4~\xf6\xab\xa5]" +
	"\xc7\xee\xfa\x1ec\xb9`\xfc\xa7\xd4\x16\xee9\xfd\xdb\xe5" +
	"\xde\x0b\x9d*i\x82\xa2\xb8\x96\xa0/\xadEY\xb5\xeb" +
	"RU\xafS\xf4\x18\xb9K)\x7f1\xa4\xe8e\x8c\xc1" +
	"k\x0e\xae\xb9\xd0\x82\xa4B\xae\x87D:\x0b\x1a=\x1b" +
	"\x12-<\x13\xe3\xf1hl\xb5x\xeft<\x03[+" +
	"^\xa8\xbe\xcf4\xa5\xb2\xb2\xd0|\x8c \x8b_s\xa1" +
	"\x1c\xff\x1f\x8c\xf8o\x00\x00\x00\xff\xffWi\x9dd"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_fcf6ac08e448a6ac,
		Nodes: []uint64{
			0x8a1df0335afc249a,
			0x8b1fd983f1df482d,
			0x8eb96dceb6a99ebd,
			0x8f58928e854cd4f5,
			0x957cbefc645fd307,
			0xa404c24b5375b9e4,
			0xa97471079836f720,
			0xab133d2062f6cc53,
			0xb2029ff7b712d18a,
			0xb2250c16d3064727,
			0xcc2d04cc26d4f6a5,
			0xcc7efefbb528cd6c,
			0xcdcf42beb2537d20,
			0xd6a4f298bc0e2304,
			0xd929e054f82b286c,
			0xe54acc44b61fd7ef,
			0xe6df611247a8fc13,
			0xee93a663b2a23c03,
			0xf00b0072c6dcfae7,
			0xf1f2e144cec1f2bc,
			0xf495a555c9344000,
		},
		Compressed: true,
	})
}
