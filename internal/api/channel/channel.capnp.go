// Code generated by capnpc-go. DO NOT EDIT.

package channel

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
	fmt "fmt"
)

type Closer capnp.Client

// Closer_TypeID is the unique identifier for the type Closer.
const Closer_TypeID = 0xfad0e4b80d3779c3

func (c Closer) Close(ctx context.Context, params func(Closer_close_Params) error) (Closer_close_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Closer_close_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Closer_close_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Closer) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Closer) AddRef() Closer {
	return Closer(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Closer) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Closer) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Closer) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Closer) DecodeFromPtr(p capnp.Ptr) Closer {
	return Closer(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Closer) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Closer) IsSame(other Closer) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Closer) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Closer) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A Closer_Server is a Closer with a local implementation.
type Closer_Server interface {
	Close(context.Context, Closer_close) error
}

// Closer_NewServer creates a new Server from an implementation of Closer_Server.
func Closer_NewServer(s Closer_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Closer_Methods(nil, s), s, c)
}

// Closer_ServerToClient creates a new Client from an implementation of Closer_Server.
// The caller is responsible for calling Release on the returned Client.
func Closer_ServerToClient(s Closer_Server) Closer {
	return Closer(capnp.NewClient(Closer_NewServer(s)))
}

// Closer_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Closer_Methods(methods []server.Method, s Closer_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Closer_close{call})
		},
	})

	return methods
}

// Closer_close holds the state for a server call to Closer.close.
// See server.Call for documentation.
type Closer_close struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Closer_close) Args() Closer_close_Params {
	return Closer_close_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Closer_close) AllocResults() (Closer_close_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Results(r), err
}

// Closer_List is a list of Closer.
type Closer_List = capnp.CapList[Closer]

// NewCloser creates a new list of Closer.
func NewCloser_List(s *capnp.Segment, sz int32) (Closer_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Closer](l), err
}

type Closer_close_Params capnp.Struct

// Closer_close_Params_TypeID is the unique identifier for the type Closer_close_Params.
const Closer_close_Params_TypeID = 0xfd07d8a1cc36583c

func NewCloser_close_Params(s *capnp.Segment) (Closer_close_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Params(st), err
}

func NewRootCloser_close_Params(s *capnp.Segment) (Closer_close_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Params(st), err
}

func ReadRootCloser_close_Params(msg *capnp.Message) (Closer_close_Params, error) {
	root, err := msg.Root()
	return Closer_close_Params(root.Struct()), err
}

func (s Closer_close_Params) String() string {
	str, _ := text.Marshal(0xfd07d8a1cc36583c, capnp.Struct(s))
	return str
}

func (s Closer_close_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Closer_close_Params) DecodeFromPtr(p capnp.Ptr) Closer_close_Params {
	return Closer_close_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Closer_close_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Closer_close_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Closer_close_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Closer_close_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Closer_close_Params_List is a list of Closer_close_Params.
type Closer_close_Params_List = capnp.StructList[Closer_close_Params]

// NewCloser_close_Params creates a new list of Closer_close_Params.
func NewCloser_close_Params_List(s *capnp.Segment, sz int32) (Closer_close_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Closer_close_Params](l), err
}

// Closer_close_Params_Future is a wrapper for a Closer_close_Params promised by a client call.
type Closer_close_Params_Future struct{ *capnp.Future }

func (f Closer_close_Params_Future) Struct() (Closer_close_Params, error) {
	p, err := f.Future.Ptr()
	return Closer_close_Params(p.Struct()), err
}

type Closer_close_Results capnp.Struct

// Closer_close_Results_TypeID is the unique identifier for the type Closer_close_Results.
const Closer_close_Results_TypeID = 0xcbee5caf8b7af4ea

func NewCloser_close_Results(s *capnp.Segment) (Closer_close_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Results(st), err
}

func NewRootCloser_close_Results(s *capnp.Segment) (Closer_close_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Results(st), err
}

func ReadRootCloser_close_Results(msg *capnp.Message) (Closer_close_Results, error) {
	root, err := msg.Root()
	return Closer_close_Results(root.Struct()), err
}

func (s Closer_close_Results) String() string {
	str, _ := text.Marshal(0xcbee5caf8b7af4ea, capnp.Struct(s))
	return str
}

func (s Closer_close_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Closer_close_Results) DecodeFromPtr(p capnp.Ptr) Closer_close_Results {
	return Closer_close_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Closer_close_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Closer_close_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Closer_close_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Closer_close_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Closer_close_Results_List is a list of Closer_close_Results.
type Closer_close_Results_List = capnp.StructList[Closer_close_Results]

// NewCloser_close_Results creates a new list of Closer_close_Results.
func NewCloser_close_Results_List(s *capnp.Segment, sz int32) (Closer_close_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Closer_close_Results](l), err
}

// Closer_close_Results_Future is a wrapper for a Closer_close_Results promised by a client call.
type Closer_close_Results_Future struct{ *capnp.Future }

func (f Closer_close_Results_Future) Struct() (Closer_close_Results, error) {
	p, err := f.Future.Ptr()
	return Closer_close_Results(p.Struct()), err
}

type Sender capnp.Client

// Sender_TypeID is the unique identifier for the type Sender.
const Sender_TypeID = 0xe8bbed1438ea16ee

func (c Sender) Send(ctx context.Context, params func(Sender_send_Params) error) (Sender_send_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Sender_send_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Sender_send_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Sender) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Sender) AddRef() Sender {
	return Sender(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Sender) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Sender) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Sender) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Sender) DecodeFromPtr(p capnp.Ptr) Sender {
	return Sender(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Sender) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Sender) IsSame(other Sender) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Sender) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Sender) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A Sender_Server is a Sender with a local implementation.
type Sender_Server interface {
	Send(context.Context, Sender_send) error
}

// Sender_NewServer creates a new Server from an implementation of Sender_Server.
func Sender_NewServer(s Sender_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Sender_Methods(nil, s), s, c)
}

// Sender_ServerToClient creates a new Client from an implementation of Sender_Server.
// The caller is responsible for calling Release on the returned Client.
func Sender_ServerToClient(s Sender_Server) Sender {
	return Sender(capnp.NewClient(Sender_NewServer(s)))
}

// Sender_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Sender_Methods(methods []server.Method, s Sender_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Sender_send{call})
		},
	})

	return methods
}

// Sender_send holds the state for a server call to Sender.send.
// See server.Call for documentation.
type Sender_send struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Sender_send) Args() Sender_send_Params {
	return Sender_send_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Sender_send) AllocResults() (Sender_send_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Sender_send_Results(r), err
}

// Sender_List is a list of Sender.
type Sender_List = capnp.CapList[Sender]

// NewSender creates a new list of Sender.
func NewSender_List(s *capnp.Segment, sz int32) (Sender_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Sender](l), err
}

type Sender_send_Params capnp.Struct

// Sender_send_Params_TypeID is the unique identifier for the type Sender_send_Params.
const Sender_send_Params_TypeID = 0x8166bc9c3ded78ca

func NewSender_send_Params(s *capnp.Segment) (Sender_send_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Sender_send_Params(st), err
}

func NewRootSender_send_Params(s *capnp.Segment) (Sender_send_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Sender_send_Params(st), err
}

func ReadRootSender_send_Params(msg *capnp.Message) (Sender_send_Params, error) {
	root, err := msg.Root()
	return Sender_send_Params(root.Struct()), err
}

func (s Sender_send_Params) String() string {
	str, _ := text.Marshal(0x8166bc9c3ded78ca, capnp.Struct(s))
	return str
}

func (s Sender_send_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Sender_send_Params) DecodeFromPtr(p capnp.Ptr) Sender_send_Params {
	return Sender_send_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Sender_send_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Sender_send_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Sender_send_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Sender_send_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Sender_send_Params) Value() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s Sender_send_Params) HasValue() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Sender_send_Params) SetValue(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}

// Sender_send_Params_List is a list of Sender_send_Params.
type Sender_send_Params_List = capnp.StructList[Sender_send_Params]

// NewSender_send_Params creates a new list of Sender_send_Params.
func NewSender_send_Params_List(s *capnp.Segment, sz int32) (Sender_send_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Sender_send_Params](l), err
}

// Sender_send_Params_Future is a wrapper for a Sender_send_Params promised by a client call.
type Sender_send_Params_Future struct{ *capnp.Future }

func (f Sender_send_Params_Future) Struct() (Sender_send_Params, error) {
	p, err := f.Future.Ptr()
	return Sender_send_Params(p.Struct()), err
}
func (p Sender_send_Params_Future) Value() *capnp.Future {
	return p.Future.Field(0, nil)
}

type Sender_send_Results capnp.Struct

// Sender_send_Results_TypeID is the unique identifier for the type Sender_send_Results.
const Sender_send_Results_TypeID = 0xbb3101eccc20b4eb

func NewSender_send_Results(s *capnp.Segment) (Sender_send_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Sender_send_Results(st), err
}

func NewRootSender_send_Results(s *capnp.Segment) (Sender_send_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Sender_send_Results(st), err
}

func ReadRootSender_send_Results(msg *capnp.Message) (Sender_send_Results, error) {
	root, err := msg.Root()
	return Sender_send_Results(root.Struct()), err
}

func (s Sender_send_Results) String() string {
	str, _ := text.Marshal(0xbb3101eccc20b4eb, capnp.Struct(s))
	return str
}

func (s Sender_send_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Sender_send_Results) DecodeFromPtr(p capnp.Ptr) Sender_send_Results {
	return Sender_send_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Sender_send_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Sender_send_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Sender_send_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Sender_send_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Sender_send_Results_List is a list of Sender_send_Results.
type Sender_send_Results_List = capnp.StructList[Sender_send_Results]

// NewSender_send_Results creates a new list of Sender_send_Results.
func NewSender_send_Results_List(s *capnp.Segment, sz int32) (Sender_send_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Sender_send_Results](l), err
}

// Sender_send_Results_Future is a wrapper for a Sender_send_Results promised by a client call.
type Sender_send_Results_Future struct{ *capnp.Future }

func (f Sender_send_Results_Future) Struct() (Sender_send_Results, error) {
	p, err := f.Future.Ptr()
	return Sender_send_Results(p.Struct()), err
}

type Recver capnp.Client

// Recver_TypeID is the unique identifier for the type Recver.
const Recver_TypeID = 0xdf05a90d671c0c07

func (c Recver) Recv(ctx context.Context, params func(Recver_recv_Params) error) (Recver_recv_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Recver_recv_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Recver_recv_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Recver) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Recver) AddRef() Recver {
	return Recver(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Recver) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Recver) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Recver) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Recver) DecodeFromPtr(p capnp.Ptr) Recver {
	return Recver(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Recver) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Recver) IsSame(other Recver) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Recver) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Recver) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A Recver_Server is a Recver with a local implementation.
type Recver_Server interface {
	Recv(context.Context, Recver_recv) error
}

// Recver_NewServer creates a new Server from an implementation of Recver_Server.
func Recver_NewServer(s Recver_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Recver_Methods(nil, s), s, c)
}

// Recver_ServerToClient creates a new Client from an implementation of Recver_Server.
// The caller is responsible for calling Release on the returned Client.
func Recver_ServerToClient(s Recver_Server) Recver {
	return Recver(capnp.NewClient(Recver_NewServer(s)))
}

// Recver_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Recver_Methods(methods []server.Method, s Recver_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Recv(ctx, Recver_recv{call})
		},
	})

	return methods
}

// Recver_recv holds the state for a server call to Recver.recv.
// See server.Call for documentation.
type Recver_recv struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Recver_recv) Args() Recver_recv_Params {
	return Recver_recv_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Recver_recv) AllocResults() (Recver_recv_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Recver_recv_Results(r), err
}

// Recver_List is a list of Recver.
type Recver_List = capnp.CapList[Recver]

// NewRecver creates a new list of Recver.
func NewRecver_List(s *capnp.Segment, sz int32) (Recver_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Recver](l), err
}

type Recver_recv_Params capnp.Struct

// Recver_recv_Params_TypeID is the unique identifier for the type Recver_recv_Params.
const Recver_recv_Params_TypeID = 0xdd377ddc0d2426ea

func NewRecver_recv_Params(s *capnp.Segment) (Recver_recv_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Recver_recv_Params(st), err
}

func NewRootRecver_recv_Params(s *capnp.Segment) (Recver_recv_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Recver_recv_Params(st), err
}

func ReadRootRecver_recv_Params(msg *capnp.Message) (Recver_recv_Params, error) {
	root, err := msg.Root()
	return Recver_recv_Params(root.Struct()), err
}

func (s Recver_recv_Params) String() string {
	str, _ := text.Marshal(0xdd377ddc0d2426ea, capnp.Struct(s))
	return str
}

func (s Recver_recv_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Recver_recv_Params) DecodeFromPtr(p capnp.Ptr) Recver_recv_Params {
	return Recver_recv_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Recver_recv_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Recver_recv_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Recver_recv_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Recver_recv_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Recver_recv_Params_List is a list of Recver_recv_Params.
type Recver_recv_Params_List = capnp.StructList[Recver_recv_Params]

// NewRecver_recv_Params creates a new list of Recver_recv_Params.
func NewRecver_recv_Params_List(s *capnp.Segment, sz int32) (Recver_recv_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Recver_recv_Params](l), err
}

// Recver_recv_Params_Future is a wrapper for a Recver_recv_Params promised by a client call.
type Recver_recv_Params_Future struct{ *capnp.Future }

func (f Recver_recv_Params_Future) Struct() (Recver_recv_Params, error) {
	p, err := f.Future.Ptr()
	return Recver_recv_Params(p.Struct()), err
}

type Recver_recv_Results capnp.Struct

// Recver_recv_Results_TypeID is the unique identifier for the type Recver_recv_Results.
const Recver_recv_Results_TypeID = 0xb0e88f4d0a3a1694

func NewRecver_recv_Results(s *capnp.Segment) (Recver_recv_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Recver_recv_Results(st), err
}

func NewRootRecver_recv_Results(s *capnp.Segment) (Recver_recv_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Recver_recv_Results(st), err
}

func ReadRootRecver_recv_Results(msg *capnp.Message) (Recver_recv_Results, error) {
	root, err := msg.Root()
	return Recver_recv_Results(root.Struct()), err
}

func (s Recver_recv_Results) String() string {
	str, _ := text.Marshal(0xb0e88f4d0a3a1694, capnp.Struct(s))
	return str
}

func (s Recver_recv_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Recver_recv_Results) DecodeFromPtr(p capnp.Ptr) Recver_recv_Results {
	return Recver_recv_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Recver_recv_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Recver_recv_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Recver_recv_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Recver_recv_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Recver_recv_Results) Value() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s Recver_recv_Results) HasValue() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Recver_recv_Results) SetValue(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}

// Recver_recv_Results_List is a list of Recver_recv_Results.
type Recver_recv_Results_List = capnp.StructList[Recver_recv_Results]

// NewRecver_recv_Results creates a new list of Recver_recv_Results.
func NewRecver_recv_Results_List(s *capnp.Segment, sz int32) (Recver_recv_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Recver_recv_Results](l), err
}

// Recver_recv_Results_Future is a wrapper for a Recver_recv_Results promised by a client call.
type Recver_recv_Results_Future struct{ *capnp.Future }

func (f Recver_recv_Results_Future) Struct() (Recver_recv_Results, error) {
	p, err := f.Future.Ptr()
	return Recver_recv_Results(p.Struct()), err
}
func (p Recver_recv_Results_Future) Value() *capnp.Future {
	return p.Future.Field(0, nil)
}

type SendCloser capnp.Client

// SendCloser_TypeID is the unique identifier for the type SendCloser.
const SendCloser_TypeID = 0xe9a7d19a7d14e94e

func (c SendCloser) AsSender(ctx context.Context, params func(SendCloser_asSender_Params) error) (SendCloser_asSender_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      0,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "asSender",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(SendCloser_asSender_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return SendCloser_asSender_Results_Future{Future: ans.Future()}, release
}
func (c SendCloser) AsCloser(ctx context.Context, params func(SendCloser_asCloser_Params) error) (SendCloser_asCloser_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      1,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "asCloser",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(SendCloser_asCloser_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return SendCloser_asCloser_Results_Future{Future: ans.Future()}, release
}
func (c SendCloser) Send(ctx context.Context, params func(Sender_send_Params) error) (Sender_send_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Sender_send_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Sender_send_Results_Future{Future: ans.Future()}, release
}
func (c SendCloser) Close(ctx context.Context, params func(Closer_close_Params) error) (Closer_close_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Closer_close_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Closer_close_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c SendCloser) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c SendCloser) AddRef() SendCloser {
	return SendCloser(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c SendCloser) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c SendCloser) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c SendCloser) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (SendCloser) DecodeFromPtr(p capnp.Ptr) SendCloser {
	return SendCloser(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c SendCloser) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c SendCloser) IsSame(other SendCloser) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c SendCloser) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c SendCloser) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A SendCloser_Server is a SendCloser with a local implementation.
type SendCloser_Server interface {
	AsSender(context.Context, SendCloser_asSender) error

	AsCloser(context.Context, SendCloser_asCloser) error

	Send(context.Context, Sender_send) error

	Close(context.Context, Closer_close) error
}

// SendCloser_NewServer creates a new Server from an implementation of SendCloser_Server.
func SendCloser_NewServer(s SendCloser_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(SendCloser_Methods(nil, s), s, c)
}

// SendCloser_ServerToClient creates a new Client from an implementation of SendCloser_Server.
// The caller is responsible for calling Release on the returned Client.
func SendCloser_ServerToClient(s SendCloser_Server) SendCloser {
	return SendCloser(capnp.NewClient(SendCloser_NewServer(s)))
}

// SendCloser_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func SendCloser_Methods(methods []server.Method, s SendCloser_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 4)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      0,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "asSender",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.AsSender(ctx, SendCloser_asSender{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      1,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "asCloser",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.AsCloser(ctx, SendCloser_asCloser{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Sender_send{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Closer_close{call})
		},
	})

	return methods
}

// SendCloser_asSender holds the state for a server call to SendCloser.asSender.
// See server.Call for documentation.
type SendCloser_asSender struct {
	*server.Call
}

// Args returns the call's arguments.
func (c SendCloser_asSender) Args() SendCloser_asSender_Params {
	return SendCloser_asSender_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c SendCloser_asSender) AllocResults() (SendCloser_asSender_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SendCloser_asSender_Results(r), err
}

// SendCloser_asCloser holds the state for a server call to SendCloser.asCloser.
// See server.Call for documentation.
type SendCloser_asCloser struct {
	*server.Call
}

// Args returns the call's arguments.
func (c SendCloser_asCloser) Args() SendCloser_asCloser_Params {
	return SendCloser_asCloser_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c SendCloser_asCloser) AllocResults() (SendCloser_asCloser_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SendCloser_asCloser_Results(r), err
}

// SendCloser_List is a list of SendCloser.
type SendCloser_List = capnp.CapList[SendCloser]

// NewSendCloser creates a new list of SendCloser.
func NewSendCloser_List(s *capnp.Segment, sz int32) (SendCloser_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[SendCloser](l), err
}

type SendCloser_asSender_Params capnp.Struct

// SendCloser_asSender_Params_TypeID is the unique identifier for the type SendCloser_asSender_Params.
const SendCloser_asSender_Params_TypeID = 0xbb370dcc71a43ba9

func NewSendCloser_asSender_Params(s *capnp.Segment) (SendCloser_asSender_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return SendCloser_asSender_Params(st), err
}

func NewRootSendCloser_asSender_Params(s *capnp.Segment) (SendCloser_asSender_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return SendCloser_asSender_Params(st), err
}

func ReadRootSendCloser_asSender_Params(msg *capnp.Message) (SendCloser_asSender_Params, error) {
	root, err := msg.Root()
	return SendCloser_asSender_Params(root.Struct()), err
}

func (s SendCloser_asSender_Params) String() string {
	str, _ := text.Marshal(0xbb370dcc71a43ba9, capnp.Struct(s))
	return str
}

func (s SendCloser_asSender_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SendCloser_asSender_Params) DecodeFromPtr(p capnp.Ptr) SendCloser_asSender_Params {
	return SendCloser_asSender_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SendCloser_asSender_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SendCloser_asSender_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SendCloser_asSender_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SendCloser_asSender_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// SendCloser_asSender_Params_List is a list of SendCloser_asSender_Params.
type SendCloser_asSender_Params_List = capnp.StructList[SendCloser_asSender_Params]

// NewSendCloser_asSender_Params creates a new list of SendCloser_asSender_Params.
func NewSendCloser_asSender_Params_List(s *capnp.Segment, sz int32) (SendCloser_asSender_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[SendCloser_asSender_Params](l), err
}

// SendCloser_asSender_Params_Future is a wrapper for a SendCloser_asSender_Params promised by a client call.
type SendCloser_asSender_Params_Future struct{ *capnp.Future }

func (f SendCloser_asSender_Params_Future) Struct() (SendCloser_asSender_Params, error) {
	p, err := f.Future.Ptr()
	return SendCloser_asSender_Params(p.Struct()), err
}

type SendCloser_asSender_Results capnp.Struct

// SendCloser_asSender_Results_TypeID is the unique identifier for the type SendCloser_asSender_Results.
const SendCloser_asSender_Results_TypeID = 0xca7110014301ab81

func NewSendCloser_asSender_Results(s *capnp.Segment) (SendCloser_asSender_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SendCloser_asSender_Results(st), err
}

func NewRootSendCloser_asSender_Results(s *capnp.Segment) (SendCloser_asSender_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SendCloser_asSender_Results(st), err
}

func ReadRootSendCloser_asSender_Results(msg *capnp.Message) (SendCloser_asSender_Results, error) {
	root, err := msg.Root()
	return SendCloser_asSender_Results(root.Struct()), err
}

func (s SendCloser_asSender_Results) String() string {
	str, _ := text.Marshal(0xca7110014301ab81, capnp.Struct(s))
	return str
}

func (s SendCloser_asSender_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SendCloser_asSender_Results) DecodeFromPtr(p capnp.Ptr) SendCloser_asSender_Results {
	return SendCloser_asSender_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SendCloser_asSender_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SendCloser_asSender_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SendCloser_asSender_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SendCloser_asSender_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SendCloser_asSender_Results) Sender() Sender {
	p, _ := capnp.Struct(s).Ptr(0)
	return Sender(p.Interface().Client())
}

func (s SendCloser_asSender_Results) HasSender() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s SendCloser_asSender_Results) SetSender(v Sender) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// SendCloser_asSender_Results_List is a list of SendCloser_asSender_Results.
type SendCloser_asSender_Results_List = capnp.StructList[SendCloser_asSender_Results]

// NewSendCloser_asSender_Results creates a new list of SendCloser_asSender_Results.
func NewSendCloser_asSender_Results_List(s *capnp.Segment, sz int32) (SendCloser_asSender_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[SendCloser_asSender_Results](l), err
}

// SendCloser_asSender_Results_Future is a wrapper for a SendCloser_asSender_Results promised by a client call.
type SendCloser_asSender_Results_Future struct{ *capnp.Future }

func (f SendCloser_asSender_Results_Future) Struct() (SendCloser_asSender_Results, error) {
	p, err := f.Future.Ptr()
	return SendCloser_asSender_Results(p.Struct()), err
}
func (p SendCloser_asSender_Results_Future) Sender() Sender {
	return Sender(p.Future.Field(0, nil).Client())
}

type SendCloser_asCloser_Params capnp.Struct

// SendCloser_asCloser_Params_TypeID is the unique identifier for the type SendCloser_asCloser_Params.
const SendCloser_asCloser_Params_TypeID = 0xe48d9443d96ba68d

func NewSendCloser_asCloser_Params(s *capnp.Segment) (SendCloser_asCloser_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return SendCloser_asCloser_Params(st), err
}

func NewRootSendCloser_asCloser_Params(s *capnp.Segment) (SendCloser_asCloser_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return SendCloser_asCloser_Params(st), err
}

func ReadRootSendCloser_asCloser_Params(msg *capnp.Message) (SendCloser_asCloser_Params, error) {
	root, err := msg.Root()
	return SendCloser_asCloser_Params(root.Struct()), err
}

func (s SendCloser_asCloser_Params) String() string {
	str, _ := text.Marshal(0xe48d9443d96ba68d, capnp.Struct(s))
	return str
}

func (s SendCloser_asCloser_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SendCloser_asCloser_Params) DecodeFromPtr(p capnp.Ptr) SendCloser_asCloser_Params {
	return SendCloser_asCloser_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SendCloser_asCloser_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SendCloser_asCloser_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SendCloser_asCloser_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SendCloser_asCloser_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// SendCloser_asCloser_Params_List is a list of SendCloser_asCloser_Params.
type SendCloser_asCloser_Params_List = capnp.StructList[SendCloser_asCloser_Params]

// NewSendCloser_asCloser_Params creates a new list of SendCloser_asCloser_Params.
func NewSendCloser_asCloser_Params_List(s *capnp.Segment, sz int32) (SendCloser_asCloser_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[SendCloser_asCloser_Params](l), err
}

// SendCloser_asCloser_Params_Future is a wrapper for a SendCloser_asCloser_Params promised by a client call.
type SendCloser_asCloser_Params_Future struct{ *capnp.Future }

func (f SendCloser_asCloser_Params_Future) Struct() (SendCloser_asCloser_Params, error) {
	p, err := f.Future.Ptr()
	return SendCloser_asCloser_Params(p.Struct()), err
}

type SendCloser_asCloser_Results capnp.Struct

// SendCloser_asCloser_Results_TypeID is the unique identifier for the type SendCloser_asCloser_Results.
const SendCloser_asCloser_Results_TypeID = 0xf1dd4079b7c319f1

func NewSendCloser_asCloser_Results(s *capnp.Segment) (SendCloser_asCloser_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SendCloser_asCloser_Results(st), err
}

func NewRootSendCloser_asCloser_Results(s *capnp.Segment) (SendCloser_asCloser_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SendCloser_asCloser_Results(st), err
}

func ReadRootSendCloser_asCloser_Results(msg *capnp.Message) (SendCloser_asCloser_Results, error) {
	root, err := msg.Root()
	return SendCloser_asCloser_Results(root.Struct()), err
}

func (s SendCloser_asCloser_Results) String() string {
	str, _ := text.Marshal(0xf1dd4079b7c319f1, capnp.Struct(s))
	return str
}

func (s SendCloser_asCloser_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SendCloser_asCloser_Results) DecodeFromPtr(p capnp.Ptr) SendCloser_asCloser_Results {
	return SendCloser_asCloser_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SendCloser_asCloser_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SendCloser_asCloser_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SendCloser_asCloser_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SendCloser_asCloser_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SendCloser_asCloser_Results) Closer() Closer {
	p, _ := capnp.Struct(s).Ptr(0)
	return Closer(p.Interface().Client())
}

func (s SendCloser_asCloser_Results) HasCloser() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s SendCloser_asCloser_Results) SetCloser(v Closer) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// SendCloser_asCloser_Results_List is a list of SendCloser_asCloser_Results.
type SendCloser_asCloser_Results_List = capnp.StructList[SendCloser_asCloser_Results]

// NewSendCloser_asCloser_Results creates a new list of SendCloser_asCloser_Results.
func NewSendCloser_asCloser_Results_List(s *capnp.Segment, sz int32) (SendCloser_asCloser_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[SendCloser_asCloser_Results](l), err
}

// SendCloser_asCloser_Results_Future is a wrapper for a SendCloser_asCloser_Results promised by a client call.
type SendCloser_asCloser_Results_Future struct{ *capnp.Future }

func (f SendCloser_asCloser_Results_Future) Struct() (SendCloser_asCloser_Results, error) {
	p, err := f.Future.Ptr()
	return SendCloser_asCloser_Results(p.Struct()), err
}
func (p SendCloser_asCloser_Results_Future) Closer() Closer {
	return Closer(p.Future.Field(0, nil).Client())
}

type Chan capnp.Client

// Chan_TypeID is the unique identifier for the type Chan.
const Chan_TypeID = 0x95c89fe7d966f751

func (c Chan) AsSendCloser(ctx context.Context, params func(Chan_asSendCloser_Params) error) (Chan_asSendCloser_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x95c89fe7d966f751,
			MethodID:      0,
			InterfaceName: "channel.capnp:Chan",
			MethodName:    "asSendCloser",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Chan_asSendCloser_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Chan_asSendCloser_Results_Future{Future: ans.Future()}, release
}
func (c Chan) AsRecver(ctx context.Context, params func(Chan_asRecver_Params) error) (Chan_asRecver_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x95c89fe7d966f751,
			MethodID:      1,
			InterfaceName: "channel.capnp:Chan",
			MethodName:    "asRecver",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Chan_asRecver_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Chan_asRecver_Results_Future{Future: ans.Future()}, release
}
func (c Chan) AsSender(ctx context.Context, params func(SendCloser_asSender_Params) error) (SendCloser_asSender_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      0,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "asSender",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(SendCloser_asSender_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return SendCloser_asSender_Results_Future{Future: ans.Future()}, release
}
func (c Chan) AsCloser(ctx context.Context, params func(SendCloser_asCloser_Params) error) (SendCloser_asCloser_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      1,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "asCloser",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(SendCloser_asCloser_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return SendCloser_asCloser_Results_Future{Future: ans.Future()}, release
}
func (c Chan) Send(ctx context.Context, params func(Sender_send_Params) error) (Sender_send_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Sender_send_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Sender_send_Results_Future{Future: ans.Future()}, release
}
func (c Chan) Close(ctx context.Context, params func(Closer_close_Params) error) (Closer_close_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Closer_close_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Closer_close_Results_Future{Future: ans.Future()}, release
}
func (c Chan) Recv(ctx context.Context, params func(Recver_recv_Params) error) (Recver_recv_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Recver_recv_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Recver_recv_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Chan) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Chan) AddRef() Chan {
	return Chan(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Chan) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Chan) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Chan) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Chan) DecodeFromPtr(p capnp.Ptr) Chan {
	return Chan(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Chan) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Chan) IsSame(other Chan) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Chan) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Chan) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A Chan_Server is a Chan with a local implementation.
type Chan_Server interface {
	AsSendCloser(context.Context, Chan_asSendCloser) error

	AsRecver(context.Context, Chan_asRecver) error

	AsSender(context.Context, SendCloser_asSender) error

	AsCloser(context.Context, SendCloser_asCloser) error

	Send(context.Context, Sender_send) error

	Close(context.Context, Closer_close) error

	Recv(context.Context, Recver_recv) error
}

// Chan_NewServer creates a new Server from an implementation of Chan_Server.
func Chan_NewServer(s Chan_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Chan_Methods(nil, s), s, c)
}

// Chan_ServerToClient creates a new Client from an implementation of Chan_Server.
// The caller is responsible for calling Release on the returned Client.
func Chan_ServerToClient(s Chan_Server) Chan {
	return Chan(capnp.NewClient(Chan_NewServer(s)))
}

// Chan_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Chan_Methods(methods []server.Method, s Chan_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 7)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x95c89fe7d966f751,
			MethodID:      0,
			InterfaceName: "channel.capnp:Chan",
			MethodName:    "asSendCloser",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.AsSendCloser(ctx, Chan_asSendCloser{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x95c89fe7d966f751,
			MethodID:      1,
			InterfaceName: "channel.capnp:Chan",
			MethodName:    "asRecver",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.AsRecver(ctx, Chan_asRecver{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      0,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "asSender",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.AsSender(ctx, SendCloser_asSender{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      1,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "asCloser",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.AsCloser(ctx, SendCloser_asCloser{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Sender_send{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Closer_close{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Recv(ctx, Recver_recv{call})
		},
	})

	return methods
}

// Chan_asSendCloser holds the state for a server call to Chan.asSendCloser.
// See server.Call for documentation.
type Chan_asSendCloser struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Chan_asSendCloser) Args() Chan_asSendCloser_Params {
	return Chan_asSendCloser_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Chan_asSendCloser) AllocResults() (Chan_asSendCloser_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Chan_asSendCloser_Results(r), err
}

// Chan_asRecver holds the state for a server call to Chan.asRecver.
// See server.Call for documentation.
type Chan_asRecver struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Chan_asRecver) Args() Chan_asRecver_Params {
	return Chan_asRecver_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Chan_asRecver) AllocResults() (Chan_asRecver_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Chan_asRecver_Results(r), err
}

// Chan_List is a list of Chan.
type Chan_List = capnp.CapList[Chan]

// NewChan creates a new list of Chan.
func NewChan_List(s *capnp.Segment, sz int32) (Chan_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Chan](l), err
}

type Chan_asSendCloser_Params capnp.Struct

// Chan_asSendCloser_Params_TypeID is the unique identifier for the type Chan_asSendCloser_Params.
const Chan_asSendCloser_Params_TypeID = 0xe76adde17bd7c3df

func NewChan_asSendCloser_Params(s *capnp.Segment) (Chan_asSendCloser_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Chan_asSendCloser_Params(st), err
}

func NewRootChan_asSendCloser_Params(s *capnp.Segment) (Chan_asSendCloser_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Chan_asSendCloser_Params(st), err
}

func ReadRootChan_asSendCloser_Params(msg *capnp.Message) (Chan_asSendCloser_Params, error) {
	root, err := msg.Root()
	return Chan_asSendCloser_Params(root.Struct()), err
}

func (s Chan_asSendCloser_Params) String() string {
	str, _ := text.Marshal(0xe76adde17bd7c3df, capnp.Struct(s))
	return str
}

func (s Chan_asSendCloser_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Chan_asSendCloser_Params) DecodeFromPtr(p capnp.Ptr) Chan_asSendCloser_Params {
	return Chan_asSendCloser_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Chan_asSendCloser_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Chan_asSendCloser_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Chan_asSendCloser_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Chan_asSendCloser_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Chan_asSendCloser_Params_List is a list of Chan_asSendCloser_Params.
type Chan_asSendCloser_Params_List = capnp.StructList[Chan_asSendCloser_Params]

// NewChan_asSendCloser_Params creates a new list of Chan_asSendCloser_Params.
func NewChan_asSendCloser_Params_List(s *capnp.Segment, sz int32) (Chan_asSendCloser_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Chan_asSendCloser_Params](l), err
}

// Chan_asSendCloser_Params_Future is a wrapper for a Chan_asSendCloser_Params promised by a client call.
type Chan_asSendCloser_Params_Future struct{ *capnp.Future }

func (f Chan_asSendCloser_Params_Future) Struct() (Chan_asSendCloser_Params, error) {
	p, err := f.Future.Ptr()
	return Chan_asSendCloser_Params(p.Struct()), err
}

type Chan_asSendCloser_Results capnp.Struct

// Chan_asSendCloser_Results_TypeID is the unique identifier for the type Chan_asSendCloser_Results.
const Chan_asSendCloser_Results_TypeID = 0xcbbc3fcd0d01a855

func NewChan_asSendCloser_Results(s *capnp.Segment) (Chan_asSendCloser_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Chan_asSendCloser_Results(st), err
}

func NewRootChan_asSendCloser_Results(s *capnp.Segment) (Chan_asSendCloser_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Chan_asSendCloser_Results(st), err
}

func ReadRootChan_asSendCloser_Results(msg *capnp.Message) (Chan_asSendCloser_Results, error) {
	root, err := msg.Root()
	return Chan_asSendCloser_Results(root.Struct()), err
}

func (s Chan_asSendCloser_Results) String() string {
	str, _ := text.Marshal(0xcbbc3fcd0d01a855, capnp.Struct(s))
	return str
}

func (s Chan_asSendCloser_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Chan_asSendCloser_Results) DecodeFromPtr(p capnp.Ptr) Chan_asSendCloser_Results {
	return Chan_asSendCloser_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Chan_asSendCloser_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Chan_asSendCloser_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Chan_asSendCloser_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Chan_asSendCloser_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Chan_asSendCloser_Results) SendCloser() SendCloser {
	p, _ := capnp.Struct(s).Ptr(0)
	return SendCloser(p.Interface().Client())
}

func (s Chan_asSendCloser_Results) HasSendCloser() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Chan_asSendCloser_Results) SetSendCloser(v SendCloser) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Chan_asSendCloser_Results_List is a list of Chan_asSendCloser_Results.
type Chan_asSendCloser_Results_List = capnp.StructList[Chan_asSendCloser_Results]

// NewChan_asSendCloser_Results creates a new list of Chan_asSendCloser_Results.
func NewChan_asSendCloser_Results_List(s *capnp.Segment, sz int32) (Chan_asSendCloser_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Chan_asSendCloser_Results](l), err
}

// Chan_asSendCloser_Results_Future is a wrapper for a Chan_asSendCloser_Results promised by a client call.
type Chan_asSendCloser_Results_Future struct{ *capnp.Future }

func (f Chan_asSendCloser_Results_Future) Struct() (Chan_asSendCloser_Results, error) {
	p, err := f.Future.Ptr()
	return Chan_asSendCloser_Results(p.Struct()), err
}
func (p Chan_asSendCloser_Results_Future) SendCloser() SendCloser {
	return SendCloser(p.Future.Field(0, nil).Client())
}

type Chan_asRecver_Params capnp.Struct

// Chan_asRecver_Params_TypeID is the unique identifier for the type Chan_asRecver_Params.
const Chan_asRecver_Params_TypeID = 0x891b1d7a66ab36b5

func NewChan_asRecver_Params(s *capnp.Segment) (Chan_asRecver_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Chan_asRecver_Params(st), err
}

func NewRootChan_asRecver_Params(s *capnp.Segment) (Chan_asRecver_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Chan_asRecver_Params(st), err
}

func ReadRootChan_asRecver_Params(msg *capnp.Message) (Chan_asRecver_Params, error) {
	root, err := msg.Root()
	return Chan_asRecver_Params(root.Struct()), err
}

func (s Chan_asRecver_Params) String() string {
	str, _ := text.Marshal(0x891b1d7a66ab36b5, capnp.Struct(s))
	return str
}

func (s Chan_asRecver_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Chan_asRecver_Params) DecodeFromPtr(p capnp.Ptr) Chan_asRecver_Params {
	return Chan_asRecver_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Chan_asRecver_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Chan_asRecver_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Chan_asRecver_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Chan_asRecver_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Chan_asRecver_Params_List is a list of Chan_asRecver_Params.
type Chan_asRecver_Params_List = capnp.StructList[Chan_asRecver_Params]

// NewChan_asRecver_Params creates a new list of Chan_asRecver_Params.
func NewChan_asRecver_Params_List(s *capnp.Segment, sz int32) (Chan_asRecver_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Chan_asRecver_Params](l), err
}

// Chan_asRecver_Params_Future is a wrapper for a Chan_asRecver_Params promised by a client call.
type Chan_asRecver_Params_Future struct{ *capnp.Future }

func (f Chan_asRecver_Params_Future) Struct() (Chan_asRecver_Params, error) {
	p, err := f.Future.Ptr()
	return Chan_asRecver_Params(p.Struct()), err
}

type Chan_asRecver_Results capnp.Struct

// Chan_asRecver_Results_TypeID is the unique identifier for the type Chan_asRecver_Results.
const Chan_asRecver_Results_TypeID = 0x9f8a81c20d0e72c9

func NewChan_asRecver_Results(s *capnp.Segment) (Chan_asRecver_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Chan_asRecver_Results(st), err
}

func NewRootChan_asRecver_Results(s *capnp.Segment) (Chan_asRecver_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Chan_asRecver_Results(st), err
}

func ReadRootChan_asRecver_Results(msg *capnp.Message) (Chan_asRecver_Results, error) {
	root, err := msg.Root()
	return Chan_asRecver_Results(root.Struct()), err
}

func (s Chan_asRecver_Results) String() string {
	str, _ := text.Marshal(0x9f8a81c20d0e72c9, capnp.Struct(s))
	return str
}

func (s Chan_asRecver_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Chan_asRecver_Results) DecodeFromPtr(p capnp.Ptr) Chan_asRecver_Results {
	return Chan_asRecver_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Chan_asRecver_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Chan_asRecver_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Chan_asRecver_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Chan_asRecver_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Chan_asRecver_Results) Recver() Recver {
	p, _ := capnp.Struct(s).Ptr(0)
	return Recver(p.Interface().Client())
}

func (s Chan_asRecver_Results) HasRecver() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Chan_asRecver_Results) SetRecver(v Recver) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Chan_asRecver_Results_List is a list of Chan_asRecver_Results.
type Chan_asRecver_Results_List = capnp.StructList[Chan_asRecver_Results]

// NewChan_asRecver_Results creates a new list of Chan_asRecver_Results.
func NewChan_asRecver_Results_List(s *capnp.Segment, sz int32) (Chan_asRecver_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Chan_asRecver_Results](l), err
}

// Chan_asRecver_Results_Future is a wrapper for a Chan_asRecver_Results promised by a client call.
type Chan_asRecver_Results_Future struct{ *capnp.Future }

func (f Chan_asRecver_Results_Future) Struct() (Chan_asRecver_Results, error) {
	p, err := f.Future.Ptr()
	return Chan_asRecver_Results(p.Struct()), err
}
func (p Chan_asRecver_Results_Future) Recver() Recver {
	return Recver(p.Future.Field(0, nil).Client())
}

const schema_872a451f9aa74ebf = "x\xda\x94VQh\x1cU\x14\xbdwg\xde\xbc4d" +
	"\xbby\xfbb\xa5Z\x89\x95b\xa1\xb0K\xd2B#\xd1" +
	"\xb2\xbbnCl\xa0%\x936 R?\x86tb\xa9" +
	"\xdb\xb5\xddI\x8b\xa9\xe4#_A\xa5\xf8S?\x0cB" +
	"\x11\xc4\xda\x14\xa9\x1f\x16\x85\x14\x04\xf3\xa3i\x04\xfd\xd2" +
	"\x80K)T\xdaFS\x09XD!\x8c\xbc\xb7\xfbf" +
	"\xde\xecNV\xf3\x95\xf0\xde\x99{\xcf=\xf7\xdcw\xb7" +
	"\xe7z\"o\xf6&\xff\xa0\x90\xb0\x8f\x13\xcb_|s" +
	"\xf5\xc0\x877\xc7\xa7\x81=\x86\x00\x04i'\xee\xab\x1a" +
	"\xed\x08\xc8\x7f5r\x80\xfe\x8d\xfd\xd7\xc6/<\xf5\xe4" +
	"\xdb\xc08\x02\x98\xe2\x9e\x98O \x98\xbe\xfd\xd7\xf8\xf2" +
	"\xbd\xcb\xdf\xbe\x0fl\xab\xe1\x7f}\xe4\xcal\xf7\xc0\x9e" +
	"\x19\x00\xe8D\xbej\xcc\xf2G\x06\x05\xe0k\xc6\x0c\xff" +
	"\xc0\xdc\xcd\xb7\x90\x94\xff]ek\xf2\x9b\xe9w.\xd7" +
	"B\xd5r\xad\x9b\xcf\x88\\\x84\x88\\\x97\xb6\xf5\xb7\x1f" +
	"~\xef\xfe\xe7:\x99Q\x92\x16\x80W%\xe0\xb7/\x9e" +
	"^\xfa\x1d{\xe7k\x00IfJ\xdc\x9b\xfe\xd5\xe7?" +
	">\xbb\x94\xec\x9b\x07\xb6]\xdd\xb8dH\xdcL_\xc3" +
	"\"v\x9e]\xac\xdd\xd4\x82\xdad$\x0c:\xfa)&" +
	"\xbf\xcf\xdd\xbc\xa5\xd3\xfa\x8c\xbc(\x007$`\xe5\xcf" +
	"\x0b\xef^?\xfe\xf0\x96\xca\x0a\xb0o\x8b%%Xy" +
	"vW\xf2\x97\xa9\xbe\xaa\xc6g\x8d\xb4\x8b\x1b\xda\xb1\xe3" +
	"\xb5\xe4Ur;F\x9ce2\xc7\xef\x10!N\x95\x0c" +
	"\xf2\x8cEy\xc6J\xf9\x17?y}\xb9x\xe9\xe2]" +
	"\xad\x80\x9d\x96,\xe0\xf6\xc2Oo\xdd\xa9\x9e\xba\xa7u" +
	" i\xf5\x8b\x9b\x87\xdbV\x9e\xebZ\x9d\xbf\x1f\x93\xe4" +
	"\x11\x99\xe3\xeb2\xc9\xdfd\x90\x1f\xb2(?d\xa5\xfc" +
	"#\x0f\xba\xa6f\x7f\xbc\xf2 \xe6\x83\x03\xd6\xa2\x80\x01" +
	"\xf0\x01k\x86\xafZ\xbby\x86\xa6\xfc\xb5\xed\x0b_N" +
	"\xe6\xabk\xbax;\xa9\x14/C\x856\x0b\x93}\xc9" +
	"\xaf\xee\xfe\xf0OCD\xe4\x87\xe9\x1c\x1f\xa5\"\x9eM" +
	"\x07\xf9\xa4\xf8\xcf\x7f\xe1\xe5\xfdK\x1f\xfdL\xd75!" +
	"\x1d\x9aF\xe8\xf1\xc7N:\xe5\xb2[\xca\x1ac\xce\x99" +
	"\xf2\x99\xfe\xa3n\xf9\x84[\xc9zn\xf9\xc4\xaea\xa7" +
	"\xe2\x9c\xf6\x00l\xd30\x01L\x04`\xc9\xbd\x00v\x9b" +
	"\x81vW\x02\xbb\xcf;\xa5s.\xa6\x11C9\x000" +
	"\x0d\xd8\x18\xb4x\xd2)g\x1do\xc4\x1d;\xefVd" +
	"X\xe3\xb4\x17\x80P\x81\x0c\xa7<\x8ch\xb7\x19\x04 " +
	"\xd0\x1e\x95IX\xef)\x80B\x0f\x16\xf2\xc8l\x8a\xe1" +
	"|\xa0r7\x1b\x18\x02(\x1c\xc4\xc21d.\xf5\x1d" +
	"O\x14S,A\xea\x0d\xcf\xad0\xec\xb6\xcd\x04\x86\xb3" +
	"\x83\xa2\x9e\xb8\xc3<\xfa\x8a+l\x00\xd9\xe0;\xbb\x0d" +
	"1\xect\xa1\x0dC3\x16zP}\x14\x00D\x9c\xc7" +
	"m\x13\x11q\xd8@)d\x100\xcc\x11\x84h\x0d/" +
	"\x98\xc80\x8d\xc7Zk?\xe2z\xe7hi\xc2\xd3[" +
	"\xda_o\xe9\xc1\x04\xe6*\x12\x86L\xcf\x9a\xc7MR" +
	"A\xd6l\x81Z\xfe\xac\x88/I\x94&\xd0\xfbo_" +
	"i\x09\xe3|\xa5\x9bU\x05\x0d0f\x88)\x96\x84\x03" +
	"\xb25C\xd4\x1d(\x8c\xfd\x7f\xb0qdu\xc5<\x09" +
	"C\xa6\xcf@\xa8\x98v\xd8\xa4\x98\xe6\x83\x88bf\xa4" +
	"q!\xa7:\x15/2\x8f\xaf\x00\xd8\x1d\x06\xda/%" +
	"\xd0\xf7\xeaP0$!-~~\xb3\xe6\x8bka]" +
	"\x991\xf1\xa7\xc6\xc5\x98\xf0Z\xf5\xb9IfT\x98\x94" +
	"\x00\x89Y7\xe5\xac\xab\xc7\x1c\xd5\x1abl\x0f@\xa1" +
	"\x03\x0b;\x90ehJDk\xf2\xa0>\x87\x91\xc3<" +
	"\x0e#6\x8dC\\\x8b\xeb\xba6\xf146\xea@\xae" +
	"\x06m,\xe8\xa8\x9b\x12&\x08\x0bR\xbb\x1d\xd5\xdal" +
	"(Ht\xaa\xc9\"zA\x91\xc3\xf8\x82\x12\x8d\x05\x01" +
	"\x84\xaf\xa7Z\xca\xa8v0\xeb\x1d\x8a\xbe\x9ej\xeb\xa1" +
	"Z4\xb1\xafg\xe4\x09\x0c\xbc\xa33\x8d\x1c\xca\xa7S" +
	"\xb1\xd9\xd4w\xf2\xe9\x0c\xaa\x16Og\xb0\xdfbTi" +
	"=M\x9b\xe9}\xab\xf1\xeeJ`N\xba]LSH" +
	"\x07#\xc3\xa1\xb6WIn\x99\xd0\x02j\xe3\xa2\xfa\x0d" +
	"\xc3\xd8^H0B\xbbeH\xd9\xd3\x96\x13&\xad\x86" +
	"\xde\xbf\x01\x00\x00\xff\xffU\x8d\xf5\xfe"

func init() {
	schemas.Register(schema_872a451f9aa74ebf,
		0x8166bc9c3ded78ca,
		0x891b1d7a66ab36b5,
		0x95c89fe7d966f751,
		0x9f8a81c20d0e72c9,
		0xb0e88f4d0a3a1694,
		0xbb3101eccc20b4eb,
		0xbb370dcc71a43ba9,
		0xca7110014301ab81,
		0xcbbc3fcd0d01a855,
		0xcbee5caf8b7af4ea,
		0xdd377ddc0d2426ea,
		0xdf05a90d671c0c07,
		0xe48d9443d96ba68d,
		0xe76adde17bd7c3df,
		0xe8bbed1438ea16ee,
		0xe9a7d19a7d14e94e,
		0xf1dd4079b7c319f1,
		0xfad0e4b80d3779c3,
		0xfd07d8a1cc36583c)
}
