// Code generated by capnpc-go. DO NOT EDIT.

package anchor

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
)

type Anchor struct{ Client *capnp.Client }

// Anchor_TypeID is the unique identifier for the type Anchor.
const Anchor_TypeID = 0xe41237e4098ed922

func (c Anchor) Ls(ctx context.Context, params func(Anchor_ls_Params) error) (Anchor_ls_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe41237e4098ed922,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "ls",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_ls_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_ls_Results_Future{Future: ans.Future()}, release
}
func (c Anchor) Walk(ctx context.Context, params func(Anchor_walk_Params) error) (Anchor_walk_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe41237e4098ed922,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "walk",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_walk_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_walk_Results_Future{Future: ans.Future()}, release
}

func (c Anchor) AddRef() Anchor {
	return Anchor{
		Client: c.Client.AddRef(),
	}
}

func (c Anchor) Release() {
	c.Client.Release()
}

// A Anchor_Server is a Anchor with a local implementation.
type Anchor_Server interface {
	Ls(context.Context, Anchor_ls) error

	Walk(context.Context, Anchor_walk) error
}

// Anchor_NewServer creates a new Server from an implementation of Anchor_Server.
func Anchor_NewServer(s Anchor_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Anchor_Methods(nil, s), s, c, policy)
}

// Anchor_ServerToClient creates a new Client from an implementation of Anchor_Server.
// The caller is responsible for calling Release on the returned Client.
func Anchor_ServerToClient(s Anchor_Server, policy *server.Policy) Anchor {
	return Anchor{Client: capnp.NewClient(Anchor_NewServer(s, policy))}
}

// Anchor_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Anchor_Methods(methods []server.Method, s Anchor_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe41237e4098ed922,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "ls",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Ls(ctx, Anchor_ls{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe41237e4098ed922,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "walk",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Walk(ctx, Anchor_walk{call})
		},
	})

	return methods
}

// Anchor_ls holds the state for a server call to Anchor.ls.
// See server.Call for documentation.
type Anchor_ls struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Anchor_ls) Args() Anchor_ls_Params {
	return Anchor_ls_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Anchor_ls) AllocResults() (Anchor_ls_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_ls_Results{Struct: r}, err
}

// Anchor_walk holds the state for a server call to Anchor.walk.
// See server.Call for documentation.
type Anchor_walk struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Anchor_walk) Args() Anchor_walk_Params {
	return Anchor_walk_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Anchor_walk) AllocResults() (Anchor_walk_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_walk_Results{Struct: r}, err
}

type Anchor_Child struct{ capnp.Struct }

// Anchor_Child_TypeID is the unique identifier for the type Anchor_Child.
const Anchor_Child_TypeID = 0xc718781cb2553199

func NewAnchor_Child(s *capnp.Segment) (Anchor_Child, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Anchor_Child{st}, err
}

func NewRootAnchor_Child(s *capnp.Segment) (Anchor_Child, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Anchor_Child{st}, err
}

func ReadRootAnchor_Child(msg *capnp.Message) (Anchor_Child, error) {
	root, err := msg.Root()
	return Anchor_Child{root.Struct()}, err
}

func (s Anchor_Child) String() string {
	str, _ := text.Marshal(0xc718781cb2553199, s.Struct)
	return str
}

func (s Anchor_Child) Name() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Anchor_Child) HasName() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_Child) NameBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Anchor_Child) SetName(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Anchor_Child) Anchor() Anchor {
	p, _ := s.Struct.Ptr(1)
	return Anchor{Client: p.Interface().Client()}
}

func (s Anchor_Child) HasAnchor() bool {
	return s.Struct.HasPtr(1)
}

func (s Anchor_Child) SetAnchor(v Anchor) error {
	if !v.Client.IsValid() {
		return s.Struct.SetPtr(1, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client))
	return s.Struct.SetPtr(1, in.ToPtr())
}

// Anchor_Child_List is a list of Anchor_Child.
type Anchor_Child_List = capnp.StructList[Anchor_Child]

// NewAnchor_Child creates a new list of Anchor_Child.
func NewAnchor_Child_List(s *capnp.Segment, sz int32) (Anchor_Child_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Anchor_Child]{List: l}, err
}

// Anchor_Child_Future is a wrapper for a Anchor_Child promised by a client call.
type Anchor_Child_Future struct{ *capnp.Future }

func (p Anchor_Child_Future) Struct() (Anchor_Child, error) {
	s, err := p.Future.Struct()
	return Anchor_Child{s}, err
}

func (p Anchor_Child_Future) Anchor() Anchor {
	return Anchor{Client: p.Future.Field(1, nil).Client()}
}

type Anchor_ls_Params struct{ capnp.Struct }

// Anchor_ls_Params_TypeID is the unique identifier for the type Anchor_ls_Params.
const Anchor_ls_Params_TypeID = 0xc105d085735711e1

func NewAnchor_ls_Params(s *capnp.Segment) (Anchor_ls_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Anchor_ls_Params{st}, err
}

func NewRootAnchor_ls_Params(s *capnp.Segment) (Anchor_ls_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Anchor_ls_Params{st}, err
}

func ReadRootAnchor_ls_Params(msg *capnp.Message) (Anchor_ls_Params, error) {
	root, err := msg.Root()
	return Anchor_ls_Params{root.Struct()}, err
}

func (s Anchor_ls_Params) String() string {
	str, _ := text.Marshal(0xc105d085735711e1, s.Struct)
	return str
}

// Anchor_ls_Params_List is a list of Anchor_ls_Params.
type Anchor_ls_Params_List = capnp.StructList[Anchor_ls_Params]

// NewAnchor_ls_Params creates a new list of Anchor_ls_Params.
func NewAnchor_ls_Params_List(s *capnp.Segment, sz int32) (Anchor_ls_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Anchor_ls_Params]{List: l}, err
}

// Anchor_ls_Params_Future is a wrapper for a Anchor_ls_Params promised by a client call.
type Anchor_ls_Params_Future struct{ *capnp.Future }

func (p Anchor_ls_Params_Future) Struct() (Anchor_ls_Params, error) {
	s, err := p.Future.Struct()
	return Anchor_ls_Params{s}, err
}

type Anchor_ls_Results struct{ capnp.Struct }

// Anchor_ls_Results_TypeID is the unique identifier for the type Anchor_ls_Results.
const Anchor_ls_Results_TypeID = 0xe325af947f127758

func NewAnchor_ls_Results(s *capnp.Segment) (Anchor_ls_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_ls_Results{st}, err
}

func NewRootAnchor_ls_Results(s *capnp.Segment) (Anchor_ls_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_ls_Results{st}, err
}

func ReadRootAnchor_ls_Results(msg *capnp.Message) (Anchor_ls_Results, error) {
	root, err := msg.Root()
	return Anchor_ls_Results{root.Struct()}, err
}

func (s Anchor_ls_Results) String() string {
	str, _ := text.Marshal(0xe325af947f127758, s.Struct)
	return str
}

func (s Anchor_ls_Results) Children() (Anchor_Child_List, error) {
	p, err := s.Struct.Ptr(0)
	return Anchor_Child_List{List: p.List()}, err
}

func (s Anchor_ls_Results) HasChildren() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_ls_Results) SetChildren(v Anchor_Child_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewChildren sets the children field to a newly
// allocated Anchor_Child_List, preferring placement in s's segment.
func (s Anchor_ls_Results) NewChildren(n int32) (Anchor_Child_List, error) {
	l, err := NewAnchor_Child_List(s.Struct.Segment(), n)
	if err != nil {
		return Anchor_Child_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Anchor_ls_Results_List is a list of Anchor_ls_Results.
type Anchor_ls_Results_List = capnp.StructList[Anchor_ls_Results]

// NewAnchor_ls_Results creates a new list of Anchor_ls_Results.
func NewAnchor_ls_Results_List(s *capnp.Segment, sz int32) (Anchor_ls_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Anchor_ls_Results]{List: l}, err
}

// Anchor_ls_Results_Future is a wrapper for a Anchor_ls_Results promised by a client call.
type Anchor_ls_Results_Future struct{ *capnp.Future }

func (p Anchor_ls_Results_Future) Struct() (Anchor_ls_Results, error) {
	s, err := p.Future.Struct()
	return Anchor_ls_Results{s}, err
}

type Anchor_walk_Params struct{ capnp.Struct }

// Anchor_walk_Params_TypeID is the unique identifier for the type Anchor_walk_Params.
const Anchor_walk_Params_TypeID = 0xb90ffa2761585171

func NewAnchor_walk_Params(s *capnp.Segment) (Anchor_walk_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_walk_Params{st}, err
}

func NewRootAnchor_walk_Params(s *capnp.Segment) (Anchor_walk_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_walk_Params{st}, err
}

func ReadRootAnchor_walk_Params(msg *capnp.Message) (Anchor_walk_Params, error) {
	root, err := msg.Root()
	return Anchor_walk_Params{root.Struct()}, err
}

func (s Anchor_walk_Params) String() string {
	str, _ := text.Marshal(0xb90ffa2761585171, s.Struct)
	return str
}

func (s Anchor_walk_Params) Path() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Anchor_walk_Params) HasPath() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_walk_Params) PathBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Anchor_walk_Params) SetPath(v string) error {
	return s.Struct.SetText(0, v)
}

// Anchor_walk_Params_List is a list of Anchor_walk_Params.
type Anchor_walk_Params_List = capnp.StructList[Anchor_walk_Params]

// NewAnchor_walk_Params creates a new list of Anchor_walk_Params.
func NewAnchor_walk_Params_List(s *capnp.Segment, sz int32) (Anchor_walk_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Anchor_walk_Params]{List: l}, err
}

// Anchor_walk_Params_Future is a wrapper for a Anchor_walk_Params promised by a client call.
type Anchor_walk_Params_Future struct{ *capnp.Future }

func (p Anchor_walk_Params_Future) Struct() (Anchor_walk_Params, error) {
	s, err := p.Future.Struct()
	return Anchor_walk_Params{s}, err
}

type Anchor_walk_Results struct{ capnp.Struct }

// Anchor_walk_Results_TypeID is the unique identifier for the type Anchor_walk_Results.
const Anchor_walk_Results_TypeID = 0xaec21d58779cc86c

func NewAnchor_walk_Results(s *capnp.Segment) (Anchor_walk_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_walk_Results{st}, err
}

func NewRootAnchor_walk_Results(s *capnp.Segment) (Anchor_walk_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_walk_Results{st}, err
}

func ReadRootAnchor_walk_Results(msg *capnp.Message) (Anchor_walk_Results, error) {
	root, err := msg.Root()
	return Anchor_walk_Results{root.Struct()}, err
}

func (s Anchor_walk_Results) String() string {
	str, _ := text.Marshal(0xaec21d58779cc86c, s.Struct)
	return str
}

func (s Anchor_walk_Results) Anchor() Anchor {
	p, _ := s.Struct.Ptr(0)
	return Anchor{Client: p.Interface().Client()}
}

func (s Anchor_walk_Results) HasAnchor() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_walk_Results) SetAnchor(v Anchor) error {
	if !v.Client.IsValid() {
		return s.Struct.SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client))
	return s.Struct.SetPtr(0, in.ToPtr())
}

// Anchor_walk_Results_List is a list of Anchor_walk_Results.
type Anchor_walk_Results_List = capnp.StructList[Anchor_walk_Results]

// NewAnchor_walk_Results creates a new list of Anchor_walk_Results.
func NewAnchor_walk_Results_List(s *capnp.Segment, sz int32) (Anchor_walk_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Anchor_walk_Results]{List: l}, err
}

// Anchor_walk_Results_Future is a wrapper for a Anchor_walk_Results promised by a client call.
type Anchor_walk_Results_Future struct{ *capnp.Future }

func (p Anchor_walk_Results_Future) Struct() (Anchor_walk_Results, error) {
	s, err := p.Future.Struct()
	return Anchor_walk_Results{s}, err
}

func (p Anchor_walk_Results_Future) Anchor() Anchor {
	return Anchor{Client: p.Future.Field(0, nil).Client()}
}

type Host struct{ Client *capnp.Client }

// Host_TypeID is the unique identifier for the type Host.
const Host_TypeID = 0x9b4f354246f972ea

func (c Host) Join(ctx context.Context, params func(Host_join_Params) error) (Host_join_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9b4f354246f972ea,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Host",
			MethodName:    "join",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Host_join_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Host_join_Results_Future{Future: ans.Future()}, release
}
func (c Host) Ls(ctx context.Context, params func(Anchor_ls_Params) error) (Anchor_ls_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe41237e4098ed922,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "ls",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_ls_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_ls_Results_Future{Future: ans.Future()}, release
}
func (c Host) Walk(ctx context.Context, params func(Anchor_walk_Params) error) (Anchor_walk_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe41237e4098ed922,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "walk",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_walk_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_walk_Results_Future{Future: ans.Future()}, release
}

func (c Host) AddRef() Host {
	return Host{
		Client: c.Client.AddRef(),
	}
}

func (c Host) Release() {
	c.Client.Release()
}

// A Host_Server is a Host with a local implementation.
type Host_Server interface {
	Join(context.Context, Host_join) error

	Ls(context.Context, Anchor_ls) error

	Walk(context.Context, Anchor_walk) error
}

// Host_NewServer creates a new Server from an implementation of Host_Server.
func Host_NewServer(s Host_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Host_Methods(nil, s), s, c, policy)
}

// Host_ServerToClient creates a new Client from an implementation of Host_Server.
// The caller is responsible for calling Release on the returned Client.
func Host_ServerToClient(s Host_Server, policy *server.Policy) Host {
	return Host{Client: capnp.NewClient(Host_NewServer(s, policy))}
}

// Host_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Host_Methods(methods []server.Method, s Host_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 3)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9b4f354246f972ea,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Host",
			MethodName:    "join",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Join(ctx, Host_join{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe41237e4098ed922,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "ls",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Ls(ctx, Anchor_ls{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe41237e4098ed922,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "walk",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Walk(ctx, Anchor_walk{call})
		},
	})

	return methods
}

// Host_join holds the state for a server call to Host.join.
// See server.Call for documentation.
type Host_join struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Host_join) Args() Host_join_Params {
	return Host_join_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Host_join) AllocResults() (Host_join_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Host_join_Results{Struct: r}, err
}

type Host_AddrInfo struct{ capnp.Struct }

// Host_AddrInfo_TypeID is the unique identifier for the type Host_AddrInfo.
const Host_AddrInfo_TypeID = 0xdc02fe8389adfc27

func NewHost_AddrInfo(s *capnp.Segment) (Host_AddrInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Host_AddrInfo{st}, err
}

func NewRootHost_AddrInfo(s *capnp.Segment) (Host_AddrInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Host_AddrInfo{st}, err
}

func ReadRootHost_AddrInfo(msg *capnp.Message) (Host_AddrInfo, error) {
	root, err := msg.Root()
	return Host_AddrInfo{root.Struct()}, err
}

func (s Host_AddrInfo) String() string {
	str, _ := text.Marshal(0xdc02fe8389adfc27, s.Struct)
	return str
}

func (s Host_AddrInfo) Id() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Host_AddrInfo) HasId() bool {
	return s.Struct.HasPtr(0)
}

func (s Host_AddrInfo) IdBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Host_AddrInfo) SetId(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Host_AddrInfo) Addrs() (capnp.DataList, error) {
	p, err := s.Struct.Ptr(1)
	return capnp.DataList{List: p.List()}, err
}

func (s Host_AddrInfo) HasAddrs() bool {
	return s.Struct.HasPtr(1)
}

func (s Host_AddrInfo) SetAddrs(v capnp.DataList) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewAddrs sets the addrs field to a newly
// allocated capnp.DataList, preferring placement in s's segment.
func (s Host_AddrInfo) NewAddrs(n int32) (capnp.DataList, error) {
	l, err := capnp.NewDataList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.DataList{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// Host_AddrInfo_List is a list of Host_AddrInfo.
type Host_AddrInfo_List = capnp.StructList[Host_AddrInfo]

// NewHost_AddrInfo creates a new list of Host_AddrInfo.
func NewHost_AddrInfo_List(s *capnp.Segment, sz int32) (Host_AddrInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Host_AddrInfo]{List: l}, err
}

// Host_AddrInfo_Future is a wrapper for a Host_AddrInfo promised by a client call.
type Host_AddrInfo_Future struct{ *capnp.Future }

func (p Host_AddrInfo_Future) Struct() (Host_AddrInfo, error) {
	s, err := p.Future.Struct()
	return Host_AddrInfo{s}, err
}

type Host_join_Params struct{ capnp.Struct }

// Host_join_Params_TypeID is the unique identifier for the type Host_join_Params.
const Host_join_Params_TypeID = 0xbd73545a5fa114d8

func NewHost_join_Params(s *capnp.Segment) (Host_join_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Host_join_Params{st}, err
}

func NewRootHost_join_Params(s *capnp.Segment) (Host_join_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Host_join_Params{st}, err
}

func ReadRootHost_join_Params(msg *capnp.Message) (Host_join_Params, error) {
	root, err := msg.Root()
	return Host_join_Params{root.Struct()}, err
}

func (s Host_join_Params) String() string {
	str, _ := text.Marshal(0xbd73545a5fa114d8, s.Struct)
	return str
}

func (s Host_join_Params) Peers() (Host_AddrInfo_List, error) {
	p, err := s.Struct.Ptr(0)
	return Host_AddrInfo_List{List: p.List()}, err
}

func (s Host_join_Params) HasPeers() bool {
	return s.Struct.HasPtr(0)
}

func (s Host_join_Params) SetPeers(v Host_AddrInfo_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewPeers sets the peers field to a newly
// allocated Host_AddrInfo_List, preferring placement in s's segment.
func (s Host_join_Params) NewPeers(n int32) (Host_AddrInfo_List, error) {
	l, err := NewHost_AddrInfo_List(s.Struct.Segment(), n)
	if err != nil {
		return Host_AddrInfo_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Host_join_Params_List is a list of Host_join_Params.
type Host_join_Params_List = capnp.StructList[Host_join_Params]

// NewHost_join_Params creates a new list of Host_join_Params.
func NewHost_join_Params_List(s *capnp.Segment, sz int32) (Host_join_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Host_join_Params]{List: l}, err
}

// Host_join_Params_Future is a wrapper for a Host_join_Params promised by a client call.
type Host_join_Params_Future struct{ *capnp.Future }

func (p Host_join_Params_Future) Struct() (Host_join_Params, error) {
	s, err := p.Future.Struct()
	return Host_join_Params{s}, err
}

type Host_join_Results struct{ capnp.Struct }

// Host_join_Results_TypeID is the unique identifier for the type Host_join_Results.
const Host_join_Results_TypeID = 0xb6797da7a5731184

func NewHost_join_Results(s *capnp.Segment) (Host_join_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Host_join_Results{st}, err
}

func NewRootHost_join_Results(s *capnp.Segment) (Host_join_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Host_join_Results{st}, err
}

func ReadRootHost_join_Results(msg *capnp.Message) (Host_join_Results, error) {
	root, err := msg.Root()
	return Host_join_Results{root.Struct()}, err
}

func (s Host_join_Results) String() string {
	str, _ := text.Marshal(0xb6797da7a5731184, s.Struct)
	return str
}

// Host_join_Results_List is a list of Host_join_Results.
type Host_join_Results_List = capnp.StructList[Host_join_Results]

// NewHost_join_Results creates a new list of Host_join_Results.
func NewHost_join_Results_List(s *capnp.Segment, sz int32) (Host_join_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Host_join_Results]{List: l}, err
}

// Host_join_Results_Future is a wrapper for a Host_join_Results promised by a client call.
type Host_join_Results_Future struct{ *capnp.Future }

func (p Host_join_Results_Future) Struct() (Host_join_Results, error) {
	s, err := p.Future.Struct()
	return Host_join_Results{s}, err
}

type Container struct{ Client *capnp.Client }

// Container_TypeID is the unique identifier for the type Container.
const Container_TypeID = 0x985d35a971e549f7

func (c Container) Get(ctx context.Context, params func(Container_get_Params) error) (Container_get_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x985d35a971e549f7,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Container",
			MethodName:    "get",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Container_get_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Container_get_Results_Future{Future: ans.Future()}, release
}
func (c Container) Set(ctx context.Context, params func(Container_set_Params) error) (Container_set_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x985d35a971e549f7,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Container",
			MethodName:    "set",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Container_set_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Container_set_Results_Future{Future: ans.Future()}, release
}
func (c Container) Ls(ctx context.Context, params func(Anchor_ls_Params) error) (Anchor_ls_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe41237e4098ed922,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "ls",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_ls_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_ls_Results_Future{Future: ans.Future()}, release
}
func (c Container) Walk(ctx context.Context, params func(Anchor_walk_Params) error) (Anchor_walk_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe41237e4098ed922,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "walk",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_walk_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_walk_Results_Future{Future: ans.Future()}, release
}

func (c Container) AddRef() Container {
	return Container{
		Client: c.Client.AddRef(),
	}
}

func (c Container) Release() {
	c.Client.Release()
}

// A Container_Server is a Container with a local implementation.
type Container_Server interface {
	Get(context.Context, Container_get) error

	Set(context.Context, Container_set) error

	Ls(context.Context, Anchor_ls) error

	Walk(context.Context, Anchor_walk) error
}

// Container_NewServer creates a new Server from an implementation of Container_Server.
func Container_NewServer(s Container_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Container_Methods(nil, s), s, c, policy)
}

// Container_ServerToClient creates a new Client from an implementation of Container_Server.
// The caller is responsible for calling Release on the returned Client.
func Container_ServerToClient(s Container_Server, policy *server.Policy) Container {
	return Container{Client: capnp.NewClient(Container_NewServer(s, policy))}
}

// Container_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Container_Methods(methods []server.Method, s Container_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 4)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x985d35a971e549f7,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Container",
			MethodName:    "get",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Get(ctx, Container_get{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x985d35a971e549f7,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Container",
			MethodName:    "set",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Set(ctx, Container_set{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe41237e4098ed922,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "ls",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Ls(ctx, Anchor_ls{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe41237e4098ed922,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "walk",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Walk(ctx, Anchor_walk{call})
		},
	})

	return methods
}

// Container_get holds the state for a server call to Container.get.
// See server.Call for documentation.
type Container_get struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Container_get) Args() Container_get_Params {
	return Container_get_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Container_get) AllocResults() (Container_get_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Container_get_Results{Struct: r}, err
}

// Container_set holds the state for a server call to Container.set.
// See server.Call for documentation.
type Container_set struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Container_set) Args() Container_set_Params {
	return Container_set_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Container_set) AllocResults() (Container_set_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Container_set_Results{Struct: r}, err
}

type Container_get_Params struct{ capnp.Struct }

// Container_get_Params_TypeID is the unique identifier for the type Container_get_Params.
const Container_get_Params_TypeID = 0xa22b0239f9511bd3

func NewContainer_get_Params(s *capnp.Segment) (Container_get_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Container_get_Params{st}, err
}

func NewRootContainer_get_Params(s *capnp.Segment) (Container_get_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Container_get_Params{st}, err
}

func ReadRootContainer_get_Params(msg *capnp.Message) (Container_get_Params, error) {
	root, err := msg.Root()
	return Container_get_Params{root.Struct()}, err
}

func (s Container_get_Params) String() string {
	str, _ := text.Marshal(0xa22b0239f9511bd3, s.Struct)
	return str
}

// Container_get_Params_List is a list of Container_get_Params.
type Container_get_Params_List = capnp.StructList[Container_get_Params]

// NewContainer_get_Params creates a new list of Container_get_Params.
func NewContainer_get_Params_List(s *capnp.Segment, sz int32) (Container_get_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Container_get_Params]{List: l}, err
}

// Container_get_Params_Future is a wrapper for a Container_get_Params promised by a client call.
type Container_get_Params_Future struct{ *capnp.Future }

func (p Container_get_Params_Future) Struct() (Container_get_Params, error) {
	s, err := p.Future.Struct()
	return Container_get_Params{s}, err
}

type Container_get_Results struct{ capnp.Struct }

// Container_get_Results_TypeID is the unique identifier for the type Container_get_Results.
const Container_get_Results_TypeID = 0x81777f8fd3e4f661

func NewContainer_get_Results(s *capnp.Segment) (Container_get_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Container_get_Results{st}, err
}

func NewRootContainer_get_Results(s *capnp.Segment) (Container_get_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Container_get_Results{st}, err
}

func ReadRootContainer_get_Results(msg *capnp.Message) (Container_get_Results, error) {
	root, err := msg.Root()
	return Container_get_Results{root.Struct()}, err
}

func (s Container_get_Results) String() string {
	str, _ := text.Marshal(0x81777f8fd3e4f661, s.Struct)
	return str
}

func (s Container_get_Results) Data() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return []byte(p.Data()), err
}

func (s Container_get_Results) HasData() bool {
	return s.Struct.HasPtr(0)
}

func (s Container_get_Results) SetData(v []byte) error {
	return s.Struct.SetData(0, v)
}

// Container_get_Results_List is a list of Container_get_Results.
type Container_get_Results_List = capnp.StructList[Container_get_Results]

// NewContainer_get_Results creates a new list of Container_get_Results.
func NewContainer_get_Results_List(s *capnp.Segment, sz int32) (Container_get_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Container_get_Results]{List: l}, err
}

// Container_get_Results_Future is a wrapper for a Container_get_Results promised by a client call.
type Container_get_Results_Future struct{ *capnp.Future }

func (p Container_get_Results_Future) Struct() (Container_get_Results, error) {
	s, err := p.Future.Struct()
	return Container_get_Results{s}, err
}

type Container_set_Params struct{ capnp.Struct }

// Container_set_Params_TypeID is the unique identifier for the type Container_set_Params.
const Container_set_Params_TypeID = 0x9f8adcb0cba2a9b5

func NewContainer_set_Params(s *capnp.Segment) (Container_set_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Container_set_Params{st}, err
}

func NewRootContainer_set_Params(s *capnp.Segment) (Container_set_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Container_set_Params{st}, err
}

func ReadRootContainer_set_Params(msg *capnp.Message) (Container_set_Params, error) {
	root, err := msg.Root()
	return Container_set_Params{root.Struct()}, err
}

func (s Container_set_Params) String() string {
	str, _ := text.Marshal(0x9f8adcb0cba2a9b5, s.Struct)
	return str
}

func (s Container_set_Params) Data() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return []byte(p.Data()), err
}

func (s Container_set_Params) HasData() bool {
	return s.Struct.HasPtr(0)
}

func (s Container_set_Params) SetData(v []byte) error {
	return s.Struct.SetData(0, v)
}

// Container_set_Params_List is a list of Container_set_Params.
type Container_set_Params_List = capnp.StructList[Container_set_Params]

// NewContainer_set_Params creates a new list of Container_set_Params.
func NewContainer_set_Params_List(s *capnp.Segment, sz int32) (Container_set_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Container_set_Params]{List: l}, err
}

// Container_set_Params_Future is a wrapper for a Container_set_Params promised by a client call.
type Container_set_Params_Future struct{ *capnp.Future }

func (p Container_set_Params_Future) Struct() (Container_set_Params, error) {
	s, err := p.Future.Struct()
	return Container_set_Params{s}, err
}

type Container_set_Results struct{ capnp.Struct }

// Container_set_Results_TypeID is the unique identifier for the type Container_set_Results.
const Container_set_Results_TypeID = 0x92fd002763530732

func NewContainer_set_Results(s *capnp.Segment) (Container_set_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Container_set_Results{st}, err
}

func NewRootContainer_set_Results(s *capnp.Segment) (Container_set_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Container_set_Results{st}, err
}

func ReadRootContainer_set_Results(msg *capnp.Message) (Container_set_Results, error) {
	root, err := msg.Root()
	return Container_set_Results{root.Struct()}, err
}

func (s Container_set_Results) String() string {
	str, _ := text.Marshal(0x92fd002763530732, s.Struct)
	return str
}

// Container_set_Results_List is a list of Container_set_Results.
type Container_set_Results_List = capnp.StructList[Container_set_Results]

// NewContainer_set_Results creates a new list of Container_set_Results.
func NewContainer_set_Results_List(s *capnp.Segment, sz int32) (Container_set_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Container_set_Results]{List: l}, err
}

// Container_set_Results_Future is a wrapper for a Container_set_Results promised by a client call.
type Container_set_Results_Future struct{ *capnp.Future }

func (p Container_set_Results_Future) Struct() (Container_set_Results, error) {
	s, err := p.Future.Struct()
	return Container_set_Results{s}, err
}

const schema_efb5a91f96d44de3 = "x\xda\xa4T]\x88\x1bU\x14>\xe7\xde;\x9dU6" +
	"\xc6\x9b\x1b\xa9]-\xc1\x92e\xebj\x97&\xba\x88\x05" +
	"I\xd6\xfa\xd7\xa2\x98\xa9\x16\x17Ad\xc8L7\xd1t" +
	"\x92\x9d\x99%\xfa \xa5\xa8\x94\xfa`qQQ\x14\xc4" +
	"\x05\x91}\xa8\x8a\xb0\x82\xc2>(\x88\x8a\x08b\x15T" +
	"*R\xba}\x11D\xec\x83\xd2\xc5u\xe4\xde\xc9\xcd\x0c" +
	"q7 \xbe\x042\xe7;\xdf\xf7\xdd\xef\x9e{\xf6\x8e" +
	"\x90*+eNm\x03b\xddkl\x8b\xec?\xd6\xce" +
	"\x9c:\xd6=\x0e|;\x02\x18h\x02\xdc\xb4\x87\x8e!" +
	"\xa0\x98\xa6\x15\xc0\x9f\xcb\xe6\x03\xf5\x89\x8dEUf\xb2" +
	"zXVY\xf4\xe7\x81\x0b\xf3\xcb\xd3\x8f\xbc\x02<C" +
	"\xa3\xf3\xf7}\xfbray\xe57\x00\x14\xb7\xd1\x8f\xc4" +
	"\x9d\xd4\x04\x103\xf4\x84x\x81n\x07\x88~\xf1/\xdd" +
	"u\xfb\xf4\xfd\xaf\xfd\x0b|\x9c.\x8a\x93\x12\"^\xa2" +
	"w\x8bU\x05^Y^\xfa\xf2\xbd\xb3\xcf\xbd\x91\xb6t" +
	"\x9a\xe6\xa4\xa5\x15i):s\x8du\xe9Vr\xc3\x12" +
	"$\xa6\xbe\x93u\x16\xb5>\x7f\xbd;\xbb\xf3\x93w\x80" +
	"\xe7\xfb\xad\xab\xf4r\xd9\xfa\xa9j}\x86\x07o\xbd\xfd" +
	"\xd4\x93\x1f\x00\xcf\xf5Z\xc5\x05\xba\x0e,\x9a\xb7f\xed" +
	"\x89\xf5\xec\x87\xe9\xce/(\x91\x9d_\xa9\xce\xef\xf3o" +
	">\xfa\xf0\x83\xc1j\xdc\xa9\x00\xe2Wz\x11P\xfc\xae" +
	"\xea\xe7\xf8C\xc1\xb3_\x1b\x1f\xc7\x04\x8a\xf9:v\x11" +
	"X\xf4j\xe9\xf0\xfb\xd7>q\xf5g\xb2\x10\xed\xfa\xe1" +
	"\xf9\xcb\xd6n\xc9\xad\x81A$\xc2`\xdf\x08\xae\xb0\x19" +
	"\xd6\x05\x8c&\xfe:}\xf2\xe9\xbf\xc9Y)\x92\x84\x16" +
	"c\x9b\xecG\xb1\xa0\xb0\xf3\x0a;\xdb\xcd\x1d{\xf1\xdd" +
	"\xf1\xf3)\xc7\xe2'\xb6\x0e(\xce1i\xa8/5\x98" +
	"\xf9U\xc6\x92\xd8i\xc8\xcc\xc7\x8d\x13b\xc10\xe1\xc6" +
	"\xc8\xf6\xea\x8d\xb6?U\xa7v\xc7\xeb\xec\xdb\xdf\xf6B" +
	"\xbb\xe9\xb9\xfe\xd4\x9c\x1b\x16\x0f\xb9\xc1B\x8b\x86\x81\xc5" +
	"(\x03`\x08\xc03\x93\x00\xd6\x08E+O0\xeb\xd8" +
	"\xa1\x8d\x19 \x98\x01\xdc\x92(H\x11\xf5A\xa8A\x95" +
	"\x18UC\xb4F\xa8\x01\xd0\xbfb\xd4\xf3\xc9K\xbb\x80" +
	"\xf0q\x13\xb1?\x1f\xa8F\x136\x16\xf9\x0eY\xcb\x98" +
	"\xe6\x9c\x1bV\xd1\x0c\xe4\xaf\xc50\x15\x01\xc0\x80\xe6=" +
	"\xed\x00C\x85I\"\xc7\x83\xd1\x8c\xe3\xf8\x07\xbc#m" +
	"\x00\xb0\x982\xa2\xaf\x1d\xf5\xe4p>\x09\x84\x1bf\xf6" +
	"\xb1v\xd3\x1b\xa2\xb3Y\x005\xdb\xb7\x8f\xe2\xff\x0br" +
	".\xe1\x19\xc0\xcc\xc4\xff\xbav\xeb\xf18\xea0P\xc7" +
	"\xe8k\xedK\xb4*q+\xf2\x94wD\x9e\xd2%:" +
	"\xa7pJ\x9e\xb4x\xa8\x12S\x0e\x11U\xb6\x02\xd8\xea" +
	"x\x1d;l\xe0(\x10\x1c\x1d\"S+(\x924G" +
	"\xb9\xc7Q$X\xe8\xb8\xae\x1f\xe0\x15\x805\x8axe" +
	"ry\x80\xf2\xe3\x00k\xcf[+\xd0\xac\x9b\xd7\xf77" +
	"\x9a-t\xe2\xd9\xd3\xa2\xd7K\xe3E\x8a\xd6^\x82\x1c" +
	"1\x8f\xf2\xe3\x1e\x19\xe0n\x8a\xd6\xcd\x04\xb3\x9e}\xd4" +
	"\xd5\xa7\xf9Oi\xc63F\x8f\xb4\x07\x14\xc76S," +
	"\xf7\x14\xef H\x9b\x8e\xd6+\xd8\x8e\x93\xc4 'f" +
	"\xd8\xe1\xf5\xcd\xa53=\x08`\x8dR\xb4v\x13\x8c\xea" +
	"\x8df\xcb\xf1]\x0f\x00\x92d\xfb[k Y\xd4\xe4" +
	"f\xa3\xed\xab\xe1O\xf6\x1b\x96\x0b2K\xa7\xf7\x86\xf5" +
	"FD\xbd\xa9xiL\xbfa\xbdnQol\xbec" +
	"R\xbda\xda\x0a\xaa\x98\x95\xe3T\xc5\x1a\xe2?\x01\x00" +
	"\x00\xff\xff\x10\xc7\xcd["

func init() {
	schemas.Register(schema_efb5a91f96d44de3,
		0x81777f8fd3e4f661,
		0x92fd002763530732,
		0x985d35a971e549f7,
		0x9b4f354246f972ea,
		0x9f8adcb0cba2a9b5,
		0xa22b0239f9511bd3,
		0xaec21d58779cc86c,
		0xb6797da7a5731184,
		0xb90ffa2761585171,
		0xbd73545a5fa114d8,
		0xc105d085735711e1,
		0xc718781cb2553199,
		0xdc02fe8389adfc27,
		0xe325af947f127758,
		0xe41237e4098ed922)
}
